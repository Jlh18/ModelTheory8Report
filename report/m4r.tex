\documentclass{article}
\usepackage[tmargin = 30mm,bmargin = 30mm]{geometry}
% \usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Set the monospace font
\usepackage{inconsolata}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
\newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}

\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Ax-Grothendieck and Lean}
\author{Joseph Hua}
\maketitle

\tableofcontents

\newpage
\section{Introduction}
\input{src/intro.tex}

\section{Model Theory Background}
\input{src/language.tex}

\section{Internal completeness and soundness for ring theories}
\input{src/internalCompletenessAndSoundness.tex}

\section{Internal completeness and soundness
  for Ax-Grothendieck}
\input{src/AxGroth.tex}

\section{The Locally Finite Case}
\input{src/locally_finite.tex}

\section{The Lefschetz Principle}
\input{src/Lefschetz.tex}

\section{Vaught's test and Upwards L\"{o}wenheim-Skolem}
\input{src/vaught.tex}

\subsubsection{Adding distinct constant symbols}

%? Where to talk about is_algebraic ∧ cardinality choice

Suppose we have a language $L$ and a consistent theory $T$ that has
an infinite model $M$, as well as an infinite cardinal $\kappa$.
Our first goal is to make a consistent theory $T_\kappa$
in a language $L_{\kappa}$ such that any model of $T_{\kappa}$
is size at least $\kappa$.

\textit{The language extended to have $\kappa$ many symbols:}
For design reasons it is convenient to work generally.
We will do the following
\begin{enumerate}
  \item Define the type of language morphisms $\texttt{L1} \to^{L} \texttt{L2}$
  \item Define the sum of two languages \texttt{L1.sum L2}
        and the language morphisms into the sum.
  \item Define the language that has constant symbols indexed by a type $\al$,
        called \texttt{of\_constants $\al$}.
        In our situation we will take $\al$ to be \texttt{$\ka$.out},
        which is a type of cardinality $\kappa$ (by the axiom of choice)
  \item Define the theory \texttt{distinct\_constants $\al$}
        in the language \texttt{of\_constants $\al$}
        that consists of $\texttt{a} \ne \texttt{b}$
        for each pair of distinct terms \texttt{a b : $\al$}.
  \item Define the induced $\texttt{L2}$-theory
        from a morphism of languages $\texttt{L1} \to^{L} \texttt{L2}$ and
        an \texttt{L1}-theory
  \item Make the sum of the languages $L$ (from the above hypotheses)
        and \texttt{of\_constants $\al$}.
        We are interested in taking the union of the induced theory from \texttt{T}
        and the induced theory from
        \texttt{distinct\_constants $\al$}.
        We call this theory \texttt{union\_add\_distinct\_constants T $\al$}
  \item Show that \texttt{union\_add\_distinct\_constants T $\al$} is consistent
        when $T$ has an infinite model
\end{enumerate}

$(1)$ A morphism of languages consists of a map on function symbols
and a map on relation symbols (for each arity).
\begin{lstlisting}
structure Lhom (L1 L2 : Language) :=
(on_function : ∀{n}, L1.functions n → L2.functions n)
(on_relation : ∀{n}, L1.relations n → L2.relations n) \end{lstlisting}
We denote this type by $\texttt{L1} \to^{L} \texttt{L2}$.

$(2)$ The sum of two languages takes two languages and makes the
disjoint sum of the function symbols and relation symbols of
each arity.
\begin{lstlisting}
def sum (L1 L2 : Language) : Language :=
⟨λn, L1.functions n ⊕ L2.functions n, λ n, L1.relations n ⊕ L2.relations n⟩ \end{lstlisting}
The obvious morphisms into the sum are from the maps into the disjoint
sum of types
\begin{lstlisting}
def sum_inl {L L' : Language} : L →ᴸ L.sum L' :=
⟨λn, sum.inl, λ n, sum.inl⟩

def sum_inr {L L' : Language} : L' →ᴸ L.sum L' :=
⟨λn, sum.inr, λ n, sum.inr⟩ \end{lstlisting}

$(3)$ \texttt{of\_constants $\al$} sets $\al$ as the set of function symbols
of arity $0$, and makes no other function or relation symbols.
\begin{lstlisting}
def of_constants (α : Type*) : Language :=
{ functions := λ n, match n with | 0 := α | (n+1) := pempty end,
  relations := λ _, pempty } \end{lstlisting}

$(4)$ We first make a function from the product $\al \times \al$ to
the set of sentences, that takes $(x_1,x_2)$ and returns the sentence
$x_{1} \ne x_{2}$.
Then the image of the complement of the diagonal in $\al \times \al$
is the theory we want.

\begin{lstlisting}
def distinct_constants_aux (x : α × α) : sentence (Language.of_constants α) :=
∼ (bd_const x.fst ≃ bd_const x.snd)

def distinct_constants : Theory (Language.of_constants α) :=
set.image (distinct_constants_aux _) { x : α × α | x.fst ≠ x.snd } \end{lstlisting}

$(5)$ The theory induced by a language morphism is constructed by
taking image of the induced map from \texttt{L1}-sentences
to \texttt{L2}-sentences.
This in turn is a special case of the induced map on bounded formulas,
which is made by induction on bounded formulas and bounded terms.
We don't go through the details of this;
the code is from \texttt{flypitch} and can be found in
\texttt{language\_extension.lean}.

$(6)$ The theory we are interested in is the latter of the following
\begin{lstlisting}
def add_distinct_constants : Theory $ L.sum (Language.of_constants α) :=
Theory_induced Lhom.sum_inr $ distinct_constants _

def union_add_distinct_constants (T : Theory L) (α : Type u) :=
(Theory_induced Lhom.sum_inl T : Theory $ L.sum (of_constants α)) ∪ add_distinct_constants α \end{lstlisting}
It combines the induced theories from the maps into the sum,
starting with the theory $T$ we want to build a $\kappa$-sized
model for and adding $\kappa$ many symbols to it.

$(7)$ Suppose $T$ is a theory with an infinite model $M$ and $\al$ is a type.
We want to show

\begin{lstlisting}
lemma is_consistent_union_add_distinct_constants {T : Theory L} (α : Type u)
  {M : Structure L} (hMinf : infinite M) (hMT : M ⊨ T):
  is_consistent $ union_add_distinct_constants T α
\end{lstlisting}

\linkto{compactness_consistency}{Compactness} tells us we only
need to show that a finite subset of $\al$ is consistent.
So we can take our original model $M$ and realize finitely many
distinct constant symbols from $\al$ in $M$ as distinct elements,
as $M$ is infinite.
To this end let's suppose we have
\[\texttt{Tfin} \cup \texttt{con\_fin} = \texttt{fs}\]
where \texttt{Tfin} and \texttt{con\_fin} are respectively
finite subsets of $T$ and $\texttt{add\_distinct\_constants} \al$.

\begin{lstlisting}
  rw compactness',
  intros fs hfsTα,
  rw model_existence,
  obtain ⟨Tfin, con_fin, hfs, hTfin, h_con_fin⟩ := finset.subset_union_elim hfsTα, \end{lstlisting}

We need to pick out all the constant symbols that appeared in
\texttt{con\_fin} (the details of which we will not go through).
We call the set of these constant symbols $\al\texttt{\_fin}$,
and note that it must be finite,
hence has an injection into $M$ (by choice).

\begin{lstlisting}
  set αfin : finset α := constants_appearing_in (of_constants.preimage con_fin)
    with hαfin,
  let on_αfin : αfin ↪ M := classical.choice ((cardinal.le_def αfin M).1
    (le_of_lt $ cardinal.finset_lt_infinite hMinf)),
\end{lstlisting}

We can extend this to a full realization of $M$ has a structure in the
language \texttt{L.sum (of\_constants $\al$)}.
Since $M$ is non-empty, we can send every symbol not in $\al\texttt{\_fin}$
to some arbitrary element (by choice).
To instantiate the goal with this structure, we make a general function

\begin{lstlisting}
def sum_Structure : Structure (L.sum (of_constants α)) :=
{ carrier := S,
  fun_map := λ n f, sum.cases_on f (λ f, S.fun_map f) $ of_constants.fun_map c,
  rel_map := λ n r, sum.cases_on r (λ r, S.rel_map r) pempty.elim } \end{lstlisting}

which takes a map interpreting the extra constant symbols
and produces a structure in the extended language.

\begin{lstlisting}
  have hM0 : nonempty M := infinite.nonempty _,
  set c : α → M :=
    λ x, dite (x ∈ αfin) (λ h, on_αfin ⟨x,h⟩) (λ _, classical.choice hM0) with hc,
  refine ⟨ Language.of_constants.sum_Structure c , hM0 , _ ⟩, \end{lstlisting}

It remains to show that this structure is a model of the theory \texttt{fs}.
That it models a the subset of $T$ is tedious to show but clear\footnote{
  The lemmas used to show that \texttt{sum\_Structure c} models the induced
  theory could be generalized to say that if the
  interpretation maps agree upon restriction to the smaller language
  then the extended structure will model the induced theory. }.

\begin{lstlisting}
  rw [← hfs, finset.coe_union, all_realize_sentence_union],
  split,
  { apply all_realize_sentence_of_subset _ hTfin,
    apply Language.of_constants.sum_Structure_Theory_induced hMT },
  { sorry }, \end{lstlisting}

That it models \texttt{con\_fin} requires a lot of rewriting but
boils down to the fact that the realization of constant symbols
was an injection when restricted to the symbols from \texttt{con\_fin}.
We omit the rest of the code.

\subsubsection{\texttt{term\_model}}

Recalling that our goal is to construct a model of a fixed cardinality,
we can move on to designing our model.
In \texttt{flypitch} this construction is called \texttt{term\_model}.
In brief, given an $L$-theory $T$, the structure consists of:
\begin{itemize}
  \item The collection of $L$-terms with no variables (\texttt{closed\_term L})
        up to equality as deduced by $T$ as the
        carrier type for the structure.
        Formally this is the quotient by the relation
        \[ t \sim s \iff T \vDash t = s \]
  \item To interpret function symbols, we need to take a
        symbol $f$ of arity $n$ and a \texttt{dvector} of closed terms
        (up to equivalence) and return (the equivalence class of) a closed term.
        The term we pick is naturally $f$
        applied to the previous $n$ closed terms (using \texttt{bd\_apps}).
        One must check that this is respects the equivalence relation.
  \item Similarly to interpret relation symbols, we need to take a
        symbol $r$ of arity $n$ and a \texttt{dvector} of closed terms.
        The term we pick is $r$ applied to the previous $n$ closed terms
        (using \texttt{bd\_apps\_rel}).
\end{itemize}

Of course this construction is not always going to give a model of the
theory, since there are theories that have no models.
However, in suitable conditions we will have that for any $L$-sentence $\phi$
\[
  T \vDash \phi \quad \text{ if and only if } \quad
  \texttt{term\_model T} \vDash \phi
\]
These conditions are
\begin{itemize}
  \item $T$ is a \linkto{is_complete_theory}{maximal complete theory}
        (called \texttt{is\_complete} in \texttt{flypitch}).
  \item The theory $T$ is Henkin, or has the witness property,
        or $L$ has enough constant symbols with respect to $T$:
\begin{lstlisting}
def has_enough_constants (T : Theory L) :=
∃(C : Π(f : bounded_formula L 1), L.constants),
  ∀(f : bounded_formula L 1), T ⊨ ∃' f ⟹ f[bd_const (C f)/0] \end{lstlisting}
        This says for each formula with one free-variable
        there is a constant symbol that would witness the
        existence of a term satisfying the formula in any model.
\end{itemize}

We demonstrate the role of these conditions in the following.
To prove
\[ T \vDash \phi \quad \text{ if and only if } \quad
  \texttt{term\_model T} \vDash \phi \]
for all sentences $\phi$, we induct on $\phi$.
For backwards direction on the $\forall$ case
we are showing that
\[ \texttt{term\_model T} \vDash \forall x, \phi \quad \text{ implies }
  \quad T \vDash \forall x, \phi \]

Assume $\texttt{term\_model} \vDash \forall x, \phi$.
By \textbf{maximality} either $T \vDash \forall x, \phi$ or
$T \vDash \exists x, \neg \phi$.
It suffices to refute the latter case.
Suppose $T \vDash \exists x, \neg \phi$.
As $T$ is \textbf{Henkin},
there is some constant symbol $c$ such that $T \vDash \neg \phi_{c}$
where $\phi_{c}$ is the sentence with $x$ replaced for $c$.
Since $T$ is \textbf{consistent} this implies $T \nvDash \phi_{c}$,
and by the induction hypothesis $\texttt{term\_model} \nvDash \phi_{c}$.
However, $c$ is realized as some \texttt{a : term\_model},
thus by our assumption $\texttt{term\_model} \vDash \phi(a)$,
and a bit of work shows $\texttt{term\_model} \vDash \phi_{c}$,
a contradiction.

\subsubsection{Henkinization}

The above indicates we must extend to a further language and a further theory
in the language, such that the extended theory is maximally consistent and Henkin.
We start with a consistent theory $T_{\kappa}$
(which in our situation is the theory with extra $\kappa$ constant symbols).
The first thing to do is to make it Henkin, ensuring it is still consistent,
we call the language we extended to $L_{H}$ and the new $L_{H}$-theory $T_{H}$.
Secondly, we throw in enough formulas to make it maximally consistent,
and call this new theory $T_{m}$.
All of this is done in \texttt{flypitch} and can mostly be found in \texttt{henkin.lean}.
An overview follows.

The second step can be done in either of the following ways:
\begin{itemize}
  \item Since the theory $T_{H}$ is consistent, it has a $L_{H}$-model,
        hence the set $T_{m}$ of $L_{H}$-sentences satisfied by the $L_{H}$-model is a
        $L_{H}$-theory extending $T_{H}$.
        It is maximal by the law of the excluded middle:
        the model $M$ either satisfies a formula or not,
        hence
        \[ M \vDash \phi \quad \text{ or } \quad M \vDash \neg \phi \]
        $T_{m}$ is consistent since $M$ is a model.\footnote{Note that
          $T \nvDash \phi$ does not imply $T \vDash \NOT \phi$ in general.
          This implication holds if and only if $T$ is complete.
          Thus we needed to appeal to a model in the above.}
  \item We can use Zorn's lemma: the set of consistent $L_{H}$-theories extending
        $T_{H}$ is non-empty as $T$ is in the set.
        Any chain of consistent $L_{H}$-theories extending $T_{H}$ is bounded
        above by a consistent theory since we can take the union of them,
        and check consistency using \linkto{compactness_consistency}{compactness}.
        One can check that this set theoretic maximality corresponds to
        the definition of a maximal consistent theory.
        Consistency is given for free by Zorn.
\end{itemize}
In the \texttt{flypitch} project, the setup of first order logic
syntax rather than its semantics means the Zorn approach is most natural.

The first step requires recursively defined languages extending one another
\[ L_{0} \to^{L} L_{1} \to^{L} \dots \]
and theories in each language such that the induced theories
at each level are sub-theories of the next

\[\begin{tikzcd}[row sep = tiny]
	{\texttt{T}_0} && {\texttt{induce T}_0 \subs \texttt{T}_1} \\
	{\texttt{Theory L}_0} && {\texttt{Theory L}_1}
	\arrow["{\texttt{induce}}", from=2-1, to=2-3]
	\arrow[shorten <=17pt, shorten >=2pt, maps to, from=1-1, to=1-3]
\end{tikzcd}\]

Specifically, the inductive step is
\begin{lstlisting}
inductive henkin_language_functions (L : Language.{u}) : ℕ → Type u
| inc : ∀ {n}, L.functions n → henkin_language_functions n
| wit : bounded_formula L 1 → henkin_language_functions 0 \end{lstlisting}
At each step we make a language $L_{i+1}$
inheriting all the function symbols from $L_{i}$ via \texttt{inc},
and for each $L_{i}$-formula $\phi$ with one free variable, we introduce a
new constant symbol \texttt{wit $\phi$} for that specific formula.

Then we can then make the new $L_{i+1}$-theory $T_{i+1}$ by taking the induced theory of
$T_{i}$ and adding a new sentence $\exists \phi \implies \phi(\texttt{wit } \phi)$
(as an induced $L_{i+1}$-sentence) for each $L_{i}$-formula $\phi$ with one free variable.

\begin{lstlisting}
def wit_property {L : Language} (f : bounded_formula L 1) (c : L.constants) :
  sentence L := (∃'f) ⟹ f[bd_const c/0]

def henkin_theory_step {L} (T : Theory L) : Theory $ henkin_language_step L :=
Theory_induced henkin_language_inclusion T ∪
(λ f : bounded_formula L 1,
  wit_property (henkin_language_inclusion.on_bounded_formula f) (wit' f)) '' (set.univ : set $ bounded_formula L 1)
\end{lstlisting}

Each $T_{i+1}$ is consistent since $T_{i}$ is consistent;
a model of $T_{i}$ will be a model of the new theory.
Indeed if \texttt{a : M} realizes $\exists \phi$
then we can interpret $\texttt{wit } \phi$ as \texttt{a},
satisfying the new sentences in $T_{i+1}$.

Hence we can take the colimit of these languages \texttt{L\_infty}
(which amounts to a union of the function symbols in set theory)
\[\begin{tikzcd}
	{\texttt{L}_0} & {\texttt{L}_1} & \cdots \\
	&& {\texttt{L\_infty}}
	\arrow[from=1-1, to=1-2]
	\arrow[from=1-2, to=1-3]
	\arrow[from=1-1, to=2-3]
	\arrow[from=1-2, to=2-3]
	\arrow[dotted, from=1-3, to=2-3]
\end{tikzcd}\]
and take the union of the induced theories in \texttt{L\_infty}
to be our desired theory \texttt{T\_infty}.

\begin{itemize}
  \item
        \texttt{T\_infty} is consistent since it is finitely consistent
        (at each step the new theory $T_{i+1}$ is consistent
        and since the theories form a chain,
        any finite subset will be a subset of some $T_{i}$).
  \item
        \texttt{T\_infty} is Henkin since any \texttt{L\_infty}-formula in one free variable
        is an induced formula from some $L_{i}$, which is witnessed by a constant symbol
        from $L_{i+1}$ according to theory $T_{i+1}$, which is embedded in \texttt{T\_infty}.
\end{itemize}

Both of these steps are combined together as

\begin{lstlisting}
def completion_of_henkinization {L} {T : Theory L} (hT : is_consistent T) : Theory (henkin_language) := sorry
\end{lstlisting}

We are now ready to prove Upwards L\"{o}wenheim-Skolem
sans the part about cardinality.

\begin{lstlisting}
theorem has_sized_model_of_has_infinite_model [is_algebraic L] {T : Theory L} {κ : cardinal}
  (hκ : ∀ n, #(L.functions n) ≤ κ) (hωκ : ω ≤ κ) :
  (∃ M : Structure L, nonempty M ∧ M ⊨ T ∧ infinite M) →
  ∃ M : Structure L, nonempty M ∧ M ⊨ T ∧ #M = κ :=
begin
  rintro ⟨ M , hM0, hMT, hMinf ⟩, \end{lstlisting}

Supposing $T$ is consistent, we can come up with a model $M$.
We can then add $\kappa$ many constant symbols to form $L_\kappa$
and ensure they are all distinct in theory $T_\kappa$,
which is consistent by our work above.
\begin{lstlisting}
  set Tκ := union_add_distinct_constants T κ.out,
  have hTκ_consis := is_consistent_union_add_distinct_constants κ.out hMinf hMT, \end{lstlisting}
We henkinize $T_\kappa$ then take the maximal consistent $L_{2}$-theory $T_{2}$
extending that (where $L_{2} := \texttt{henkin\_language}$).
We know that this is consistent, maximal and Henkin,
hence \texttt{term\_model T2} satisfies exactly the formulas
that appear in $T_{2}$.
However, we need to take the \texttt{reduct} of \texttt{term\_model T2},
since we only want an $L$-structure which models the $L$-theory $T$.
The reduct simply takes the original carrier set and realizes symbols
as the realization of their images in the extended language.
This is denoted \texttt{M[[ $\iota : L_{0} \to^{L} L_{1}$ ]]}, where $M$ is
an $L_{1}$-structure.
We first take the reduct to $L_{\kappa}$, then down to $L$.

\begin{lstlisting}
  set T2 := completion_of_henkinization hTκ_consis,
  use (term_model T2)[[ henkin_language_over ]]
    [[(Lhom.sum_inl : L →ᴸ L.sum (of_constants κ.out))]], \end{lstlisting}

It remains to show that this reduct is non-empty and a model of $T$,
which follows from general theory about reducts and API for
\texttt{completion\_of\_henkinization} and \texttt{term\_model}.

\begin{lstlisting}
  split,
  -- the reduction of a non-empty model is non-empty
  { apply fol.nonempty_term_model, exact completion_of_henkinization_is_henkin _, },
  split,
  -- this reduction models T
  { apply Lhom.reduct_Theory_induced Lhom.sum.is_injective_inl,
    have h := reduct_of_complete_henkinization_models_T hTκ_consis,
    simp only [all_realize_sentence_union] at h,
    exact h.1 },
  sorry, \end{lstlisting}

The final goal is finding the cardinality of \texttt{term\_model},
which we explore in the next subsection.

\subsubsection{Cardinality of \texttt{term\_model}}

Our goal is
\begin{lstlisting}
# ↥(term_model T2[[henkin_language_over]][[Lhom.sum_inl]]) = κ \end{lstlisting}
which says the cardinality of the carrier type of the
reduct of \texttt{term\_model T2} to $L$ is $\kappa$.
We first show 
\begin{lstlisting}
# κ ≤ ↥(term_model T2[[henkin_language_over]][[Lhom.sum_inl]]) \end{lstlisting}
To show this, it suffices to show
\begin{itemize}
  \item The carrier type of any \texttt{(Language.of\_constants $\al$)}-model of
        \texttt{distinct\_constants $\al$} is at least size $\# \al$
  \item The reduct of \texttt{term\_model} to
        \texttt{Language.of\_constants $\kappa$.out} is a model of
        \texttt{distinct\_constants $\kappa$.out}
  \item The carrier type in the goal (the reduct of \texttt{term\_model} to \texttt{L})
        equals to the carrier type of the reduct of \texttt{term\_model} to
        \texttt{Language.of\_constants $\al$}
\end{itemize}

The first point follows from our definition of \texttt{distinct\_constants}:
Suppose $M$ is a (\texttt{Language.of\_constants $\al$})-model of
\texttt{distinct\_constants $\al$}.
Then to show that $\# \al \le \# M$ it suffices to show that the function
taking any $a : \al$ to its realization in $M$ is an injection.
\begin{lstlisting}
lemma all_realize_sentence_distinct_constants (M : Structure _) (hM : M ⊨ distinct_constants α) : #α ≤ #M :=
begin
  apply @cardinal.mk_le_of_injective _ _ (λ a, M.constants a),
  intros x y hfxy, \end{lstlisting}
Let two terms $x$ and $y : \al$ be equal upon realization in $M$,
and suppose for a contradiction $x \ne y$.
Then by definition the sentence $x \ne y$ is in
of the theory \texttt{distinct\_constants $/al$}, so
$x$ and $y$ are not equal upon realization in $M$,
a model of \texttt{distinct\_constants}.
\begin{lstlisting}
  by_contra' hxy,
  rw all_realize_sentence_image at hM,
  apply hM ⟨x,y⟩ hxy,
  simp only [Structure.constants] at hfxy,
  simp [bd_const, hfxy],
end \end{lstlisting}

The second point follows from the fact that
for any injective morphism of languages,
the reduct of models of induced theories are models of the original theories.

The third point is just by simplification, which I have extracted for clarity.
Putting the three parts together we have the inequality
\begin{lstlisting}
    have hle : #κ.out ≤ #((term_model T2)[[henkin_language_over]]
             [[(Lhom.sum_inr : _ →ᴸ L.sum (of_constants κ.out))]]),
    { apply all_realize_sentence_distinct_constants,
      apply Lhom.reduct_Theory_induced Lhom.sum.is_injective_inr,
      have h := reduct_of_complete_henkinization_models_T hTκ_consis,
      simp only [all_realize_sentence_union] at h,
      exact h.2 },
    { simp only [fol.Lhom.reduct_coe, cardinal.mk_out] at hle ⊢,
      exact hle } } \end{lstlisting}

The goal is now to show that
\begin{lstlisting}
# ↥(term_model T2[[henkin_language_over]][[Lhom.sum_inl]]) ≤ κ \end{lstlisting}
This will require opening up the definition of \texttt{term\_model}.
We know that \texttt{term\_model T2} is a quotient of the type of closed
terms in the language \texttt{henkin\_language}, thus

\begin{lstlisting}
lemma card_le_closed_term : #(term_model T) ≤ #(closed_term L) :=
cardinal.mk_le_of_surjective quotient.surjective_quotient_mk' \end{lstlisting}

Since intuitively induction on terms produces well-founded trees,
we should be able to bound \texttt{closed\_term L} by
the function symbols in $L$.
More precisely, it is the total number of function symbols of all arities,
or it is $\om$ (the countably infinite cardinal) if there are finitely many
function symbols.
This is non-trivial, and we will show it later. %?
\begin{lstlisting}
lemma bounded_preterm_le_functions {l} : #(bounded_preterm L n l) ≤
  max (cardinal.sum (λ n : ulift.{u} (ℕ), #(L.functions n.down))) ω := sorry \end{lstlisting}

Applying this, we see that it suffices to show two facts



\begin{lstlisting}
lemma card_le_functions : #(term_model T) ≤
  max (cardinal.sum (λ n : ulift.{u} (ℕ), #(L.functions n.down))) ω :=
calc #(term_model T)
      ≤ #(closed_term L) : card_le_closed_term T
  ... ≤ max (cardinal.sum (λ n : ulift.{u} ℕ, #(L.functions n.down))) ω :
    cardinal.bounded_preterm_le_functions _

lemma card_le_cardinal {κ : cardinal.{u}} (hωκ : ω ≤ κ)
  (hκ : ∀ n : ulift.{u} ℕ, #(L.functions n.down) ≤ κ) : #(term_model T) ≤ κ :=
begin
  apply le_trans (card_le_functions T),
  apply max_le _ hωκ,
  apply le_trans (cardinal.sum_le_sup (λ n : ulift.{u} ℕ, #(L.functions n.down))),
  apply le_trans (cardinal.mul_le_max _ _),
  apply max_le _ hωκ,
  apply max_le,
  { simp [hωκ] },
  { rw cardinal.sup_le,
    exact hκ },
end

\end{lstlisting}

\bibliography{refs}{}
\bibliographystyle{abbrv}










\end{document}
