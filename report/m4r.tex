\documentclass{article}
\usepackage[tmargin = 30mm,bmargin = 30mm]{geometry}
% \usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Set the monospace font
\usepackage{inconsolata}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
\newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}

\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Ax-Grothendieck and Lean}
\author{Joseph Hua}
\maketitle

\tableofcontents

\newpage
\section{Introduction}
\input{src/intro.tex}

\section{Model Theory Background}
\input{src/language.tex}

\section{Internal completeness and soundness for ring theories}
\input{src/internalCompletenessAndSoundness.tex}

\section{Internal completeness and soundness
  for Ax-Grothendieck}
\input{src/AxGroth.tex}

\section{The Locally Finite Case}
\input{src/locally_finite.tex}

\section{The Lefschetz Principle}
\input{src/Lefschetz.tex}

\section{Vaught's test and Upwards L\"{o}wenheim-Skolem}
\input{src/vaught.tex}

\subsection{Cardinality lemmas}

\subsubsection{Terms}

In this subsection we prove that the number of preterms is bounded by
the number of function symbols in the language.

\begin{lstlisting}
lemma bounded_preterm_le_functions {l} : #(bounded_preterm L n l) ≤
  max (cardinal.sum (λ n : ulift.{u} (ℕ), #(L.functions n.down))) ω := sorry \end{lstlisting}

There should be many approaches to this problem.
Mine was to note that preterms can be interpreted
the collection of lists of preterm symbols that satisfy certain rules.
Then the list of all these symbols can be easily bounded above.
For example, the term \texttt{0 + (1 * x\_0)}
will be written as a list of symbols
(the natural numbers for \texttt{app} will be explained later)
\begin{lstlisting}
  [app,10]
    ++ ([app,1]
      ++ [func +]
      ++ ([app,4] ++ ([app,1] ++ [func *] ++ [func 1]) ++ [var 0]))
    ++ [func 0]
\end{lstlisting}

The \textbf{preterm symbols} can be made as an inductive type
\begin{lstlisting}
inductive preterm_symbol (L : Language) : Type u
| nat : ℕ → preterm_symbol
| var : Π {l}, fin l → preterm_symbol
| func : Π {l}, L.functions l → preterm_symbol
| app : preterm_symbol \end{lstlisting}

Then we \textbf{inject} \texttt{bounded\_preterm L n l}
into the collection of lists of preterm symbols.

\begin{lstlisting}
def preterm_symbol_of_preterm {n} : ∀ {l},
  bounded_preterm L n l → list (preterm_symbol L)
| _ (&k)         := [ preterm_symbol.var k ]
| l (bd_func f)  := [ preterm_symbol.func f ]
| l (bd_app t s) := [ preterm_symbol.app,
  preterm_symbol.nat (preterm_symbol_of_preterm t).length ]
  ++ preterm_symbol_of_preterm t ++ preterm_symbol_of_preterm s
 \end{lstlisting}

The choice of each list is designed to capture all
the pieces of data that went into constructing the term.
If the term was built as a variable \texttt{\&k}
then we only need to include the data that
it was built as a variable symbol and that it used bounded natural $k$,
so we take the list consisting of only
the preterm symbol \texttt{[ preterm\_symbol.var k ]}.
The case for a function symbol is similar.
More interestingly, when the preterm is built from
applying a preterm \texttt{t : bounded\_preterm L n (l + 1)}
to a preterm \texttt{s : bounded\_preterm L n 0},
we preserve the data of $t$ and $s$ by appending their
inductively given lists to the end of everything else we need.
It turns out that preserving the length of the list from $t$
is important for showing injectivity.

To \textbf{show injectivity} of the above we induct on $L$-terms $x$ and $y$.
There are $9$ cases to work on since there are $3$ cases for $x$ and $y$
respectively.

\begin{lstlisting}
lemma preterm_symbol_of_preterm_injective {l} :
  function.injective (@preterm_symbol_of_preterm L n l) :=
begin
  intros x,
  induction x with k _ _ _ tx sx htx hsx,
  { intro y,
    cases y,
    { intro h, simp only [...] at h, subst h },
    { intro h, cases h },
    { intro h, cases h } },
  { intro y,
    cases y,
    { intro h, cases h },
    { intro h, simp only [...] at h, subst h },
    { intro h, cases h } },
  { intro y,
    cases y with _ _ _ _ ty sy,
    { intro h, cases h },
    { intro h, cases h },
    { intro h, simp only [...] at h,
      obtain ⟨ ht , hs ⟩ := list.append_inj h.2 h.1,
      congr, { exact htx ht }, { exact hsx hs } } },
end \end{lstlisting}

The cases where $x$ and $y$ are not built by the same constructor
are easy to eliminate, since \texttt{no\_confusion}
for lists tells us two equal lists must have equal elements in the lists,
and \texttt{no\_confusion} for \texttt{preterm\_symbol} tells us
two equal preterm symbols must have come from the same constructor,
which yields a contradiction in each case.
This argument is hidden by the tactics \texttt{intro h, cases h},
where $h$ is the assumption that $x$ and $y$
make equal lists of preterm symbols.

The remaining cases: when both are variable symbols or both are function symbols
then we are assuming two lists with a single element are equal,
since the elements are the same constructor applied to some variable,
those variables must be equal by \texttt{no\_confusion} for
\texttt{preterm\_symbol}.
We thus have that $x = y$.
In the case when $x$ and $y$ are both applications,
we can use \texttt{no\_confusion} for lists and
apply injectivity of \texttt{list.append}
to deduce each part of the list is equal and apply the induction hypothesis.
Injectivity of \texttt{list.append} uses equality of lengths of the
sublists, which is why we included that data in our definition of
\texttt{preterm\_symbol\_of\_preterm}.

Now that we have an injection into \texttt{list (preterm\_symbol L)}
we should \textbf{compute the cardinality} of \texttt{preterm\_symbol L},
which will determine the cardinality of lists of them.
We make a type equivalent to \texttt{preterm\_symbol L}:

\begin{lstlisting}
def preterm_symbol_equiv_fin_sum_formula_sum_nat :
  (preterm_symbol L) ≃
    (Σ l : ulift.{u} ℕ, ulift.{u} (fin l.down)) ⊕ (Σ l : ulift.{u} ℕ, L.functions l.down) ⊕ ℕ := ... \end{lstlisting}

This equivalence of types is obvious.
Equivalent types have the same cardinality, so
we can just compute the cardinality of the latter,
for which there is plenty of API.

We are ready to complete the lemma.
By the injection above we have the first inequality:
\begin{lstlisting}
lemma bounded_preterm_le_functions {l} : #(bounded_preterm L n l) ≤
  max (cardinal.sum (λ n : ulift.{u} (ℕ), #(L.functions n.down))) ω :=
calc #(bounded_preterm L n l) ≤ # (list (preterm_symbol L)) :
    cardinal.mk_le_of_injective (@preterm_symbol_of_preterm_injective L n l)
\end{lstlisting}
For an infinite type $\al$, $\# \al = \# \texttt{list } \al$.
Then replacing the cardinality along the equivalence above,
and going through some simple cardinal arithmetic proves the final inequality.
\begin{lstlisting}
  ... = # (preterm_symbol L) : cardinal.mk_list_eq_mk (preterm_symbol L)
  ... ≤ max (cardinal.sum (λ n : ulift.{u} (ℕ), #(L.functions n.down))) ω :
begin
  rw cardinal.mk_congr (preterm_symbol_equiv_fin_sum_formula_sum_nat L),
  simp only [...],
  apply le_trans (cardinal.add_le_max _ _) (max_le (max_le _ _) (le_max_right _ _)),
  { apply le_max_of_le_right,
    apply le_trans (cardinal.sum_le_sup.{u} (λ (i : ulift.{u} ℕ), (i.down : cardinal.{u}))),
    apply le_trans (cardinal.mul_le_max _ _) (max_le (max_le _ _) (le_of_eq rfl)),
    { simp },
    { rw cardinal.sup_le, intro i, apply le_of_lt, rw cardinal.lt_omega, simp, }
  },
  { apply le_trans (cardinal.add_le_max _ _) (max_le (max_le _ _) (le_max_right _ _)),
    { simp },
    { exact le_max_right _ _ } }
end \end{lstlisting}

\subsubsection{Formulas}

We make a similar construction for formulas,
where we bound the number of formulas by the number of terms.
We then utilize previous work bounding the number of terms by the
number of function symbols to improve the bound:
\begin{lstlisting}
lemma bounded_formula_le_bounded_term [is_algebraic L] {n} :
  #(bounded_formula L n) ≤ max (cardinal.sum (λ n : ulift.{u} ℕ, #(bounded_term L n.down))) ω := sorry

lemma bounded_formula_le_functions [is_algebraic L] {n} :
  #(bounded_formula L n) ≤ max (cardinal.sum (λ n : ulift.{u} ℕ, #(L.functions n.down))) ω :=
begin
  apply le_trans (bounded_formula_le_bounded_term L),
  apply max_le _ (le_max_right _ _),
  apply le_trans (cardinal.sum_le_sup _),
  simp only [cardinal.mk_denumerable],
  apply le_trans (cardinal.mul_le_max _ _),
  apply max_le _ (le_max_right _ _),
  apply max_le (le_max_right _ _),
  rw cardinal.sup_le,
  intro i,
  apply bounded_preterm_le_functions,
end \end{lstlisting}

The \textbf{formula symbols} we need are

\begin{lstlisting}
inductive formula_symbol (L : Language.{u}) : Type u
| bot : formula_symbol
| eq : formula_symbol
| imp : formula_symbol
| all : formula_symbol
| term : Π (l : ℕ), bounded_term L l → formula_symbol
| nat : ℕ → formula_symbol \end{lstlisting}

The structure of induction on formulas is more interesting than
that of terms, since the constructor \texttt{bounded\_preformula.bd\_all} takes preformulas with $n + 1$ free variables and converts them to
preformulas with $n$ free variables.
Thus we must keep track of the data of the number of free variables
when we write a formula as a list of symbols.
We do so when we \textbf{inject} formulas into lists of formula symbols.

\begin{lstlisting}
def formula_symbol_of_formula [is_algebraic L] {n} :
  bounded_formula L n → list (formula_symbol L) :=
bounded_formula.rec2
  (λ l, [formula_symbol.nat l, formula_symbol.bot]) -- ⊥
  (λ l t s, [ formula_symbol.nat l, formula_symbol.eq ,
    formula_symbol.term l t , formula_symbol.term l s ]) -- t ≃ s
  (λ _ _ r, false.elim $ Language.is_algebraic.empty_relations _ r) -- bd_rel
  (λ l ϕ ψ lϕ lψ, (formula_symbol.nat l) :: (formula_symbol.nat (list.length lϕ))
    :: (formula_symbol.nat (list.length lψ)) :: formula_symbol.imp :: lϕ.append lψ ) -- ϕ ⟹ ψ
  (λ l ϕ lϕ, (formula_symbol.nat l) :: formula_symbol.all :: lϕ) -- ∀ₗ ϕ \end{lstlisting}

Here we have taken advantage of an induction lemma made for \texttt{bounded\_{formula}}
rather than \texttt{bounded\_{preformula}}.
Note that the assumption \texttt{is\_{algebraic}} here means that we need not
worry about relation symbols.
A generalization of this work would have to include the relation symbols
in the final upper bound.

To show that this assignment is \textbf{injective},
we need to be careful.
For the induction to work on the \texttt{bd\_all} case,
we need the inducion hypothesis to include the statement about formulas
with $n+1$ many free variables.
(This is possible since we are not inducting on the naturals, but on formulas.)
We quickly find that we are in the territory of \texttt{heq},
since we need to ask for two terms of definitionally different types
\texttt{bounded\_formula L n} and \texttt{bounded\_formula L m} to be equal.
Thus we state it as follows:

\begin{lstlisting}
lemma formula_symbol_of_preformula_injective' [is_algebraic L] {n} : ∀ (x : bounded_formula L n)
  {m} (y : bounded_formula L m),
  formula_symbol_of_formula x = formula_symbol_of_formula y → x == y := sorry

lemma formula_symbol_of_preformula_injective [is_algebraic L] {n}:
  function.injective (@formula_symbol_of_formula L _ n) :=
begin
  intros x y hxy,
  have h := formula_symbol_of_preformula_injective' x y hxy,
  subst h,
end \end{lstlisting}

There are $6 * 6 = 36$ cases to check for the first lemma,
of which $30$ are quite easily resolved by applications of
\texttt{no\_confusion}.
The rest of the $6$ are resolved by careful handling of the induction
hypothesis and \texttt{heq}.

We find \textbf{an equivalent type}, whose cardinality is easy to compute:

\begin{lstlisting}
def formula_symbol_equiv_bounded_term_sum_nat :
  (formula_symbol L) ≃ ((Σ l : ulift.{u} ℕ, bounded_term L l.down) ⊕ ulift.{u} ℕ) := sorry \end{lstlisting}

Finally we conclude our computation.
By our injection into formula symbols,

\begin{lstlisting}
lemma bounded_formula_le_bounded_term [is_algebraic L] {n} :
  #(bounded_formula L n) ≤ max (cardinal.sum (λ n : ulift.{u} ℕ, #(bounded_term L n.down))) ω :=
calc #(bounded_formula L n) ≤ # (list (formula_symbol L)) :
    cardinal.mk_le_of_injective (formula_symbol_of_preformula_injective) \end{lstlisting}

Then since the type of formula symbols is infinite,
the size of lists is equal to its original size,
which is equal to the size of the equivalent type above.

\begin{lstlisting}

  ... = # (formula_symbol L) : cardinal.mk_list_eq_mk _
  ... = _ : cardinal.mk_congr formula_symbol_equiv_bounded_term_sum_nat \end{lstlisting}

The rest is simple cardinal arithmetic.

\begin{lstlisting}
  ... ≤ max (cardinal.sum (λ n : ulift.{u} ℕ, #(bounded_term L n.down))) ω : by {
  simp only [le_refl, and_true, cardinal.mk_denumerable, cardinal.mk_sum, cardinal.lift_omega,
    cardinal.mk_sigma, cardinal.lift_id],
  apply le_trans (cardinal.add_le_max _ _) (max_le (max_le _ _) (le_max_right _ _)),
  { exact le_max_left _ _ },
  { exact le_max_right _ _ } } \end{lstlisting}

\subsubsection{Henkinization}

\bibliography{refs}{}
\bibliographystyle{abbrv}










\end{document}
