\documentclass{article}
\usepackage[tmargin = 30mm,bmargin = 30mm]{geometry}
% \usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Set the monospace font
\usepackage{inconsolata}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
\newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 3pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}

\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{Ax-Grothendieck and Lean}
\author{Joseph Hua}
\maketitle

\tableofcontents

\newpage
\section{Introduction}
\input{src/intro.tex}

\section{Model Theory Background}
\input{src/language.tex}

\section{Internal completeness and soundness for ring theories}
\input{src/internalCompletenessAndSoundness.tex}

\section{Internal completeness and soundness
  for Ax-Grothendieck}
\input{src/AxGroth.tex}

\section{The Locally Finite Case}
\input{src/locally_finite.tex}

\section{The Lefschetz Principle}
\input{src/Lefschetz.tex}

\section{Vaught's test and Upwards L\"{o}wenheim-Skolem}
\input{src/vaught.tex}

\subsubsection{Adding distinct constant symbols}

%? Where to talk about is_algebraic ∧ cardinality choice

Suppose we have a language $L$ and a consistent theory $T$ that has
an infinite model $M$, as well as an infinite cardinal $\kappa$.
Our first goal is to make a consistent theory $T_\kappa$
in a language $L_{\kappa}$ such that any model of $T_{\kappa}$
is size at least $\kappa$.

\textit{The language extended to have $\kappa$ many symbols:}
For design reasons it is convenient to work generally.
We will do the following
\begin{enumerate}
  \item Define the type of language morphisms $\texttt{L1} \to^{L} \texttt{L2}$
  \item Define the sum of two languages \texttt{L1.sum L2}
        and the language morphisms into the sum.
  \item Define the language that has constant symbols indexed by a type $\al$,
        called \texttt{of\_constants $\al$}.
        In our situation we will take $\al$ to be \texttt{$\ka$.out},
        which is a type of cardinality $\kappa$ (by the axiom of choice)
  \item Define the theory \texttt{distinct\_constants $\al$}
        in the language \texttt{of\_constants $\al$}
        that consists of $\texttt{a} \ne \texttt{b}$
        for each pair of distinct terms \texttt{a b : $\al$}.
  \item Define the induced $\texttt{L2}$-theory
        from a morphism of languages $\texttt{L1} \to^{L} \texttt{L2}$ and
        an \texttt{L1}-theory
  \item Make the sum of the languages $L$ (from the above hypotheses)
        and \texttt{of\_constants $\al$}.
        We are interested in taking the union of the induced theory from \texttt{T}
        and the induced theory from
        \texttt{distinct\_constants $\al$}.
        We call this theory \texttt{union\_add\_distinct\_constants T $\al$}
  \item Show that \texttt{union\_add\_distinct\_constants T $\al$} is consistent
        when $T$ has an infinite model
\end{enumerate}

$(1)$ A morphism of languages consists of a map on function symbols
and a map on relation symbols (for each arity).
\begin{lstlisting}
structure Lhom (L1 L2 : Language) :=
(on_function : ∀{n}, L1.functions n → L2.functions n)
(on_relation : ∀{n}, L1.relations n → L2.relations n) \end{lstlisting}
We denote this type by $\texttt{L1} \to^{L} \texttt{L2}$.

$(2)$ The sum of two languages takes two languages and makes the
disjoint sum of the function symbols and relation symbols of
each arity.
\begin{lstlisting}
def sum (L1 L2 : Language) : Language :=
⟨λn, L1.functions n ⊕ L2.functions n, λ n, L1.relations n ⊕ L2.relations n⟩ \end{lstlisting}
The obvious morphisms into the sum are from the maps into the disjoint
sum of types
\begin{lstlisting}
def sum_inl {L L' : Language} : L →ᴸ L.sum L' :=
⟨λn, sum.inl, λ n, sum.inl⟩

def sum_inr {L L' : Language} : L' →ᴸ L.sum L' :=
⟨λn, sum.inr, λ n, sum.inr⟩ \end{lstlisting}

$(3)$ \texttt{of\_constants $\al$} sets $\al$ as the set of function symbols
of arity $0$, and makes no other function or relation symbols.
\begin{lstlisting}
def of_constants (α : Type*) : Language :=
{ functions := λ n, match n with | 0 := α | (n+1) := pempty end,
  relations := λ _, pempty } \end{lstlisting}

$(4)$ We first make a function from the product $\al \times \al$ to
the set of sentences, that takes $(x_1,x_2)$ and returns the sentence
$x_{1} \ne x_{2}$.
Then the image of the complement of the diagonal in $\al \times \al$
is the theory we want.

\begin{lstlisting}
def distinct_constants_aux (x : α × α) : sentence (Language.of_constants α) :=
∼ (bd_const x.fst ≃ bd_const x.snd)

def distinct_constants : Theory (Language.of_constants α) :=
set.image (distinct_constants_aux _) { x : α × α | x.fst ≠ x.snd } \end{lstlisting}

$(5)$ The theory induced by a language morphism is constructed by
taking image of the induced map from \texttt{L1}-sentences
to \texttt{L2}-sentences.
This in turn is a special case of the induced map on bounded formulas,
which is made by induction on bounded formulas and bounded terms.
We don't go through the details of this;
the code is from \texttt{flypitch} and can be found in
\texttt{language\_extension.lean}.

$(6)$ The theory we are interested in is the latter of the following
\begin{lstlisting}
def add_distinct_constants : Theory $ L.sum (Language.of_constants α) :=
Theory_induced Lhom.sum_inr $ distinct_constants _

def union_add_distinct_constants (T : Theory L) (α : Type u) :=
(Theory_induced Lhom.sum_inl T : Theory $ L.sum (of_constants α)) ∪ add_distinct_constants α \end{lstlisting}
It combines the induced theories from the maps into the sum,
starting with the theory $T$ we want to build a $\kappa$-sized
model for and adding $\kappa$ many symbols to it.

$(7)$ Suppose $T$ is a theory with an infinite model $M$ and $\al$ is a type.
We want to show

\begin{lstlisting}
lemma is_consistent_union_add_distinct_constants {T : Theory L} (α : Type u)
  {M : Structure L} (hMinf : infinite M) (hMT : M ⊨ T):
  is_consistent $ union_add_distinct_constants T α
\end{lstlisting}

\linkto{compactness_consistency}{Compactness} tells us we only
need to show that a finite subset of $\al$ is consistent.
So we can take our original model $M$ and realize finitely many
distinct constant symbols from $\al$ in $M$ as distinct elements,
as $M$ is infinite.
To this end let's suppose we have
\[\texttt{Tfin} \cup \texttt{con\_fin} = \texttt{fs}\]
where \texttt{Tfin} and \texttt{con\_fin} are respectively
finite subsets of $T$ and $\texttt{add\_distinct\_constants} \al$.

\begin{lstlisting}
  rw compactness',
  intros fs hfsTα,
  rw model_existence,
  obtain ⟨Tfin, con_fin, hfs, hTfin, h_con_fin⟩ := finset.subset_union_elim hfsTα, \end{lstlisting}

We need to pick out all the constant symbols that appeared in
\texttt{con\_fin} (the details of which we will not go through).
We call the set of these constant symbols $\al\texttt{\_fin}$,
and note that it must be finite,
hence has an injection into $M$ (by choice).

\begin{lstlisting}
  set αfin : finset α := constants_appearing_in (of_constants.preimage con_fin)
    with hαfin,
  let on_αfin : αfin ↪ M := classical.choice ((cardinal.le_def αfin M).1
    (le_of_lt $ cardinal.finset_lt_infinite hMinf)),
\end{lstlisting}

We can extend this to a full realization of $M$ has a structure in the
language \texttt{L.sum (of\_constants $\al$)}.
Since $M$ is non-empty, we can send every symbol not in $\al\texttt{\_fin}$
to some arbitrary element (by choice).
To instantiate the goal with this structure, we make a general function

\begin{lstlisting}
def sum_Structure : Structure (L.sum (of_constants α)) :=
{ carrier := S,
  fun_map := λ n f, sum.cases_on f (λ f, S.fun_map f) $ of_constants.fun_map c,
  rel_map := λ n r, sum.cases_on r (λ r, S.rel_map r) pempty.elim } \end{lstlisting}

which takes a map interpreting the extra constant symbols
and produces a structure in the extended language.

\begin{lstlisting}
  have hM0 : nonempty M := infinite.nonempty _,
  set c : α → M :=
    λ x, dite (x ∈ αfin) (λ h, on_αfin ⟨x,h⟩) (λ _, classical.choice hM0) with hc,
  refine ⟨ Language.of_constants.sum_Structure c , hM0 , _ ⟩, \end{lstlisting}

It remains to show that this structure is a model of the theory \texttt{fs}.
That it models a the subset of $T$ is tedious to show but clear\footnote{
  The lemmas used to show that \texttt{sum\_Structure c} models the induced
  theory could be generalized to say that if the
  interpretation maps agree upon restriction to the smaller language
  then the extended structure will model the induced theory. }.

\begin{lstlisting}
  rw [← hfs, finset.coe_union, all_realize_sentence_union],
  split,
  { apply all_realize_sentence_of_subset _ hTfin,
    apply Language.of_constants.sum_Structure_Theory_induced hMT },
  { sorry }, \end{lstlisting}

That it models \texttt{con\_fin} requires a lot of rewriting but
boils down to the fact that the realization of constant symbols
was an injection when restricted to the symbols from \texttt{con\_fin}.
We omit the rest of the code.

\subsubsection{\texttt{term\_model}}

Recalling that our goal is to construct a model of a fixed cardinality,
we can move on to designing our model.
In \texttt{flypitch} this construction is called \texttt{term\_model}.
In brief, given an $L$-theory $T$, the structure consists of:
\begin{itemize}
  \item The collection of $L$-terms with no variables (\texttt{closed\_term L})
        up to equality as deduced by $T$ as the
        carrier type for the structure.
        Formally this is the quotient by the relation
        \[ t \sim s \iff T \vDash t = s \]
  \item To interpret function symbols, we need to take a
        symbol $f$ of arity $n$ and a \texttt{dvector} of closed terms
        (up to equivalence) and return (the equivalence class of) a closed term.
        The term we pick is naturally $f$
        applied to the previous $n$ closed terms (using \texttt{bd\_apps}).
        One must check that this is respects the equivalence relation.
  \item Similarly to interpret relation symbols, we need to take a
        symbol $r$ of arity $n$ and a \texttt{dvector} of closed terms.
        The term we pick is $r$ applied to the previous $n$ closed terms
        (using \texttt{bd\_apps\_rel}).
\end{itemize}

Of course this construction is not always going to give a model of the
theory, since there are theories that have no models.
However, in suitable conditions we will have that for any $L$-sentence $\phi$
\[
  T \vDash \phi \quad \text{ if and only if } \quad
  \texttt{term\_model T} \vDash \phi
\]
These conditions are
\begin{itemize}
  \item $T$ is a \linkto{is_complete_theory}{maximal complete theory}
        (called \texttt{is\_complete} in \texttt{flypitch}).
  \item The theory $T$ is Henkin, or has the witness property,
        or $L$ has enough constant symbols with respect to $T$:
\begin{lstlisting}
def has_enough_constants (T : Theory L) :=
∃(C : Π(f : bounded_formula L 1), L.constants),
  ∀(f : bounded_formula L 1), T ⊨ ∃' f ⟹ f[bd_const (C f)/0] \end{lstlisting}
\end{itemize}

We demonstrate the role of these conditions in the following.
To prove
\[ T \vDash \phi \quad \text{ if and only if } \quad
  \texttt{term\_model T} \vDash \phi \]
for all sentences $\phi$, we induct on $\phi$.
For backwards direction on the $\forall$ case
we are showing that
\[ \texttt{term\_model T} \vDash \forall x, \phi \quad \text{ implies }
  \quad T \vDash \forall x, \phi \]

Assume $\texttt{term\_model} \vDash \forall x, \phi$.
By \textbf{maximality} either $T \vDash \forall x, \phi$ or
$T \vDash \exists x, \neg \phi$.
It suffices to assume the latter case and get a contradiction.
As $T$ is \textbf{Henkin},
there is some constant symbol $c$ such that $T \vDash \neg \phi_{c}$
where $\phi_{c}$ is the sentence with $x$ replaced for $c$.
Since $T$ is \textbf{consistent} this implies $T \nvDash \phi_{c}$,
and by the induction hypothesis $\texttt{term\_model} \nvDash \phi_{c}$.
However, $c$ is realized as some \texttt{a : term\_model},
thus by our assumption $\texttt{term\_model} \vDash \phi(a)$,
and a bit of work shows $\texttt{term\_model} \vDash \phi_{c}$,
a contradiction.

\subsubsection{Henkinization}

The above motivates the need to extend to a further language and a further theory
in the language, such that the extended theory is maximally consistent and Henkin.
We start with a consistent theory $T_{\kappa}$
(which in our situation is the theory with extra $\kappa$ constant symbols).
The first thing to do is to make it Henkin, ensuring it is still consistent,
we call the language we extended to $L_{H}$ and the new $L_{H}$-theory $T_{H}$.
Then we can throw in enough formulas to make it maximally consistent,
and call this new theory $T_{m}$.

The last step is very simple, and can be done in either of the following ways:
\begin{itemize}
  \item Since the theory $T_{H}$ is consistent, it has a $L_{H}$-model,
        hence the set $T_{m}$ of $L_{H}$-sentences satisfied by the $L_{H}$-model is a
        $L_{H}$-theory extending $T_{H}$.
        It is maximal by the law of the excluded middle:
        the model $M$ either satisfies a formula or not,
        hence
        \[ M \vDash \phi \quad \text{ or } \quad M \vDash \neg \phi \]
        Note that the same idea does not hold for theories in general
        since $T \nvDash \phi$ is not the same as $T \vDash \neg \phi$.
        $T_{m}$ is consistent since $M$ is a model.
  \item We can use Zorn's lemma: the set of consistent $L_{H}$-theories extending
        $T_{H}$ is non-empty as $T$ is in the set.
        Any chain of consistent $L_{H}$-theories extending $T_{H}$ is bounded
        above by a consistent theory since we can take the union of them,
        and check consistency using \linkto{compactness_consistency}{compactness}.
        One can check that this set theoretic maximality corresponds to
        the definition of a maximal consistent theory.
        Consistency is given for free by Zorn.
\end{itemize}
In the \texttt{flypitch} project, the setup of first order logic
syntax (\vdash) means avoiding the usage of models, preferring the Zorn approach.

% Extend to a Henkin theory

% Link to the right code for extending to a Henkin language and continue with the
% proof of Lowenheim until cardinality computation.



\subsubsection{Cardinality of \texttt{term\_model}}




\bibliography{refs}{}
\bibliographystyle{abbrv}










\end{document}
