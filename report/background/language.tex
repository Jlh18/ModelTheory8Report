For most definitions and proofs in this section we reference
David Marker's book on Model Theory \cite{marker}.
We introduce the formalisations of the content in \texttt{lean} alongside the theory.

\subsection{Languages}
\begin{dfn}[Language]
  A language (also known as a \textit{signature}) $\LL = ( \func , \rel )$ consists of

  \begin{itemize}
    \item A sort symbol $A$, which we will have in the background for intuition.
    \item For each natural number $n$ we have $\func n$ -
          the set of \textit{function symbols} for the language of \textit{arity} $n$.
          For some $f \in \func n$ we might write
          $f : A^{n} \to A$ to denote $f$ with its arity.
    \item For each natural number $n$ we have $\rel n$ -
          the set of \textit{relation symbols} for the language of \textit{arity} $n$.
          For some $r \in \rel n$ we might write
          $r \hookr A^{n}$ to denote $r$ with its arity.
  \end{itemize}

  The \texttt{flypitch} project implements the above definition as

  \begin{lstlisting}
    structure Language : Type (u+1) :=
      (functions : ℕ → Type u)
      (relations : ℕ → Type u)\end{lstlisting}

  This says that \texttt{Language} is a mathematical structure
  (like a group structure, or ring structure)
  that consists of two pieces of data,
  a map called \texttt{functions} and another called \texttt{relations}.
  Both take a natural number and spit out a \textit{type}
  (which in \texttt{lean} might as well mean \textit{set})
  that consists respectively of all the function symbols and relation symbols of arity $n$.

  In more detail: in type theory when we write \texttt{a:A} we mean \texttt{a} is something
  of \textit{type} \texttt{A}.
  We can draw an analogy with the set theoretic notion $a \in A$,
  but types in \texttt{lean} have slightly different
  personalities, which we will gradually introduce.
  Hence in the above definitions \texttt{functions n} and \texttt{relations n}
  are things of type \texttt{Type u}.
  \texttt{Type u} is a collection of all types at level \texttt{u},
  so things of type \texttt{Type u} are types.
  ``Types are type \texttt{Type u}.''

  For convenience we single out $0$-ary (arity $0$) functions and
  call them \textit{constant} symbols, usually denoting them by $c : A$.
  We think of these as `elements' of the sort $A$ and write $c : A$.
  This is defined in \texttt{lean} by

  \begin{lstlisting}
    def constants (L : Language) : Type u := functions 0\end{lstlisting}

  This says that \texttt{constants} takes in a language $L$ and returns a type.
  Following the \texttt{:=} we have the definition of \texttt{constants L},
  which is the type \texttt{functions 0}.
\end{dfn}

\begin{eg}
  The \linkto{dfn_rings}{language of rings}
  will be used to define the theory of rings,
  the theory of integral domains, the theory of fields, and so on.
  In the appendix we give examples:
  \begin{itemize}
    \item The \linkto{dfn_bin_rel}{language with just a single binary relation} %? missing
          can be used to define the theory of partial orders
          with the interpretation of the relation as $<$,
          to define the theory of equivalence relations with the
          interpretation of the relation as $\sim$,
          and to define the theory $\ZFC$ with the relation interpreted as $\in$.
    \item The \linkto{dfn_cat}{language of categories} %? missing
          can be used to define the theory of categories.
  \end{itemize}
  We will only be concerned with the language of rings and will
  focus our examples around this.
\end{eg}

\begin{dfn}[Language of rings]
    \link{dfn_rings}
    Let the following be the language of rings:
    \begin{itemize}
        \item The function symbols are the constant symbols $0, 1 : A$,
        the symbols for addition and multiplication $+ , \times : A^2 \to A$
        and taking for inverse $- : A \to A$.
        \item There are no relation symbols.
    \end{itemize}

    We can break this definition up into steps in \texttt{lean}.
    We first collect the constant, unary and binary symbols:

    \begin{lstlisting}
      /-- The constant symbols in RingLanguage -/
      inductive ring_consts : Type u
      | zero : ring_consts
      | one : ring_consts

      /-- The unary function symbols in RingLanguage-/
      inductive ring_unaries : Type u
      | neg : ring_unaries

      /-- The binary function symbols in RingLanguage-/
      inductive ring_binaries : Type u
      | add : ring_binaries
      | mul : ring_binaries\end{lstlisting}

    These are \textit{inductively defined types} -
    types that are `freely' generated by their constructors,
    listed below after each bar `\texttt{|}'.
    In these above cases they are particularly simple -
    the only constructors are terms in the type.
    In the appendix we give more examples of inductive types %? missing
    \begin{itemize}
      \item The \link{dfn_nat}{natural numbers} are defined as inductive types
      \item \link{dfn_list}{Lists} are defined as inductive types
      \item The \link{dfn_int}{integers} can be defined as inductive types
    \end{itemize}

    We now collect all the above into a single definition \texttt{ring funcs}
    that takes each natural \texttt{n} to the type of \texttt{n}-ary
    function symbols in the language of rings.

    \begin{lstlisting}
      /-- All function symbols in RingLanguage-/
      def ring_funcs : ℕ → Type u
      | 0 := ring_consts
      | 1 := ring_unaries
      | 2 := ring_binaries
      | (n + 3) := pempty\end{lstlisting}

    The type \texttt{pempty} is the empty type and is meant to have no terms in it,
    since we wish to have no function symbols beyond arity $2$.
    Finally we make the language of rings

    \begin{lstlisting}
      /-- The language of rings -/
      def ring_language : Language :=
      (Language.mk) (ring_funcs) (λ n, pempty)\end{lstlisting}

\end{dfn}

We use languages to express logical assertions about our structures, such as
``any degree two polynomial over my ring has a root''.
In order to do so we must introduce terms (polynomials in our case),
formulas (the assertion itself), structures and models (the ring),
and the relation between structures and formulas
(that the ring satisfies this assertion).

We want to express ``all the combinations of symbols we can make in a language''.
We can think of multivariable polynomials over the integers as such:
the only things we can write down using symbols $0,1,-,+,*$ and variables
are elements of $\Z{[x_{k}]}_{k \in \N}$.
We formalize this as terms.

\begin{dfn}[Terms]
  Let $\LL = (\func, \rel)$ be a language.
  To make a \textit{preterm} in $\LL$ with up to $n$ variables
  we can do one of three things:
  \begin{itemize}
    \item[$\vert$] For each natural number $k < n$ we create a symbol
          $x_{k}$, which we call a \textit{variable} in $A$.
          Any $x_{k}$ is a preterm (that is missing nothing).
    \item[$\vert$] If $f : A^{l} \to A$ is a function symbol then
          $f$ is a preterm that is missing $l$ inputs.
          \[ f( ? , \cdots , ? )\]
    \item[$\vert$] If $t$ is a preterm that is missing
          $l + 1$ inputs and $s$ is a preterm that is missing
          no inputs then we can \textit{apply} $t$ to $s$, obtaining
          a preterm that is missing $l$ inputs.
          \[ t(s , ? , \cdots, ? )\]
  \end{itemize}

  We only really want \textit{terms} with up to $n$ variables,
  which are defined as preterms that are missing nothing.

  \begin{lstlisting}
    inductive bounded_preterm (n : ℕ) : ℕ → Type u
    | x_ : ∀ (k : fin n), bounded_preterm 0
    | bd_func : ∀ {l : ℕ} (f : L.functions l), bounded_preterm l
    | bd_app : ∀ {l : ℕ} (t : bounded_preterm (l + 1)) (s : bounded_preterm 0), bounded_preterm l

  def bounded_term (n : ℕ) := bounded_preterm L n 0\end{lstlisting}

  To explain notation
  \begin{itemize}
    \item The second constructor says ``for all natural numbers $l$ and function symbols $f$,
          \texttt{bd\_func f} is something in \texttt{bounded\_preterm l}''.
          This makes sense since \texttt{bounded\_preterm l} is a type by the first line of code.
    \item The curley brackets just say
          ``you can leave out this input and \texttt{lean} will know what it is''.
  \end{itemize}

  To give an example of this in action we can write $x_{1} * 0$.
  We first write the individual parts, which are
  \texttt{x\_ 1}, \texttt{bd\_func mul} and
  \texttt{bd\_func zero}.
  Then we apply them to each other
  \begin{lstlisting}
    bd_app (bd_app (mul) (x_ 1)) zero \end{lstlisting}
  Naturally, we will introduce nice notation in \texttt{lean} to replace all of this.
\end{dfn}

\begin{rmk}
  There are many terminology clashes between model theory and type theory,
  since they are closely related.
  The word ``term'' in type theory refers to anything on the left of a \texttt{:} sign,
  or anything in a type.
  Terms in inductively defined types are (as mentioned before)
  freely generated symbols using the contructors.
  Analogously terms in a language are freely generated symbols using
  the symbols from the language.
\end{rmk}

One can imagine writing down any degree two polynomial over the integers
as a term in the language of rings.
In fact, we could even make degree two polynomials over any ring (if we had one):
\[ x_{0} x_{3}^{2} + x_{1} x_{3} + x_{2} \]
Here our variable is $x_{3}$, and we imaging that the other variables represent
elements of our ring.

To express ``for \textit{any} polynomial over our ring, it has a root'',
we might write
\[ \forall x_{2} x_{1} x_{0} : A, \exists x_{3} : A, x_{0} x_{3}^{2} + x_{1} x_{3} + x_{2} = 0 \]
Formulas allow us to do this.

\begin{dfn}[Formulas]
  Let $\LL$ be a language.
  A \textit{preformula} in $\LL$ with (up to) $n$ \textit{free} variables
  can be built in the following ways:
  \begin{itemize}
    \item[$\vert$] $\bot$ is an atomic preformula with $n$ free variables
          (and missing nothing).
    \item[$\vert$]
          Given terms $t, s$ with $n$ variables,
          $t = s$ is a formula with $n$ free variables (missing nothing).
    \item[$\vert$] Any relation symbol $r \hookr A^{l}$ is a preformula
          with $n$ free variables and missing $l$ inputs.
          \[ r (?, \cdots, ?)\]
    \item[$\vert$] If $\phi$ is a preformula with $n$ free variables that is missing
          $l + 1$ inputs and $t$ is a term with $n$ variables
          then we can \textit{apply} $\phi$ to $t$, obtaining
          a preformula that is missing $l$ inputs.
          \[ \phi(t , ? , \cdots, ? )\]
    \item[$\vert$] If $\phi$ and $\psi$ are preformulas with $n$ free variables
          and \textit{nothing missing} then so is $\phi \implies \psi$.
    \item[$\vert$] If $\phi$ is a preformula with $n + 1$ free variables
          and \textit{nothing missing} then $\forall x_{0}, \phi$ is a preformula
          with $n$ free variables and nothing missing.
  \end{itemize}

  We take formulas to be preformulas with nothing missing.
  Note that we take the de Brujn index convension here.
  If $\phi$ were the formula $x_{0} + x_{1} = x_{2}$ then $\forall \phi$ would be
  the formula $\forall x_{0} : A, x_{0} + x_{1} = x_{2}$,
  which is really $\forall x : A, x + x_{0} = x_{1}$,
  so that all the remaining free variables are shifted down.

  We write this in \texttt{lean},
  and also define sentences as preformulas with $0$ variables and nothing missing.
  Sentences are what we usually come up with when we make assertions.

  \begin{lstlisting}
    inductive bounded_preformula : ℕ → ℕ → Type u
    | bd_falsum {n : ℕ} : bounded_preformula n 0
    | bd_equal {n : ℕ} (t₁ t₂ : bounded_term L n) : bounded_preformula n 0
    | bd_rel {n l : ℕ} (R : L.relations l) : bounded_preformula n l
    | bd_apprel {n l : ℕ} (f : bounded_preformula n (l + 1)) (t : bounded_term L n) : bounded_preformula n l
    | bd_imp {n : ℕ} (f₁ f₂ : bounded_preformula n 0) : bounded_preformula n 0
    | bd_all {n : ℕ} (f : bounded_preformula (n+1) 0) : bounded_preformula n 0

    def bounded_formula (n : ℕ) := bounded_preformula L n 0
    def sentence := bounded_preformula L 0 0\end{lstlisting}

  Since we are working with classical logic we
  make everything else we need by use of the excluded middle:

  \begin{lstlisting}
    /-- ⊥ is for bd_falsum, ≃ for bd_equal, ⟹ for bd_imp, and ∀' for bd_all -/
    /-- we will write ~ for bd_not, ⊓ for bd_and, and infixr ⊔ for bd_or -/
    def bd_not {n} (f : bounded_formula L n) : bounded_formula L n := f ⟹ ⊥
    def bd_and {n} (f₁ f₂ : bounded_formula L n) : bounded_formula L n := ~(f₁ ⟹ ∼f₂)
    def bd_or {n} (f₁ f₂ : bounded_formula L n) : bounded_formula L n := ~f₁ ⟹ f₂
    def bd_biimp {n} (f₁ f₂ : bounded_formula L n) : bounded_formula L n := (f₁ ⟹ f₂) ⊓ (f₂ ⟹ f₁)
    def bd_ex {n} (f : bounded_formula L (n+1)) : bounded_formula L n := ~ (∀' ~ f))
  \end{lstlisting}
\end{dfn}

With just this much set up
we can already write down the sentences that describe rings.

\begin{lstlisting}
  /-- Assosiativity of addition -/
  def add_assoc : sentence ring_signature :=
    ∀' ∀' ∀' ( (x_ 0 + x_ 1) + x_ 2 ≃ x_ 0 + (x_ 1 + x_ 2) )

  /-- Identity for addition -/
  def add_id : sentence ring_signature := ∀' ( x_ 0 + 0 ≃ x_ 0 )

  /-- Inverse for addition -/
  def add_inv : sentence ring_signature := ∀' ( - x_ 0 + x_ 0 ≃ 0 )

  /-- Commutativity of addition-/
  def add_comm : sentence ring_signature := ∀' ∀' ( x_ 0 + x_ 1 ≃ x_ 1 + x_ 0 )

  /-- Associativity of multiplication -/
  def mul_assoc : sentence ring_signature :=
  ∀' ∀' ∀' ( (x_ 0 * x_ 1) * x_ 2 ≃ x_ 0 * (x_ 1 * x_ 2) )

  /-- Identity of multiplication -/
  def mul_id : sentence ring_signature :=  ∀' ( x_ 0 * 1 ≃ x_ 0 )

  /-- Commutativity of multiplication -/
  def mul_comm : sentence ring_signature := ∀' ∀' ( x_ 0 * x_ 1 ≃ x_ 1 * x_ 0   )

  /-- Distributibity -/
  def add_mul : sentence ring_signature :=
    ∀' ∀' ∀' ( (x_ 0 + x_ 1) * x_ 2 ≃ x_ 0 * x_ 2 + x_ 1 * x_ 2 )
\end{lstlisting}

We can collect all of these into one and call it the \textit{theory of rings}.

\begin{dfn}[Theory]
  Given a language $\LL$,
  a set of sentences in the language is a theory in that language.
\end{dfn}

\begin{dfn}[The theories of rings and fields]

  \begin{lstlisting}
    def ring_theory : Theory ring_signature :=
    {add_assoc, add_id, add_inv, add_comm, mul_assoc, mul_id, mul_comm, add_mul}


  \end{lstlisting}


\end{dfn}

We intend to apply the statement
``for \textit{any} polynomial over our ring, it has a root''
to a real, usable, tangible ring.
We would like the sort symbol $A$ to be interpreted as the underlying type (set)
for the ring and the function symbols to actually become maps from the ring to itself.

\begin{dfn}[Interpretation and structures]
    Given a language $\LL$, a $\LL$-\textit{structure} \texttt{M}
    interpreting $\LL$ consists of the following
    \begin{itemize}
      \item An underlying type \texttt{carrier}.
      \item Each function symbol $f : A^{n} \to A$ is interpreted as a
            function that takes an $n$-ary tuple in \texttt{carrier}
            to something in \texttt{carrier}.
      \item Each relation symbol $r \hookr A^{n}$
            is interpreted as a proposition about $n$-ary tuples in \texttt{carrier},
            which can also be viewed as the subset of the set of $n$-ary tuples
            satisfying that proposition.
    \end{itemize}

  \begin{lstlisting}
  structure Structure :=
  (carrier : Type u)
  (fun_map : ∀{n}, L.functions n → dvector carrier n → carrier)
  (rel_map : ∀{n}, L.relations n → dvector carrier n → Prop)\end{lstlisting}
\end{dfn}



% The structures in a language will become the models of theories.
% For example $\Z$ is a structure in the \linkto{dfn_rings}{language of rings},
% a model of the theory of rings but not a model of the theory of fields.
% In the language of \linkto{sig_just_one_bin_rel}{binary relations},
% $\N$ with the usual ordering $\leq$ is a structure that models of
% the theory of partial orders but not the theory of equivalence relations.

% \begin{dfn}[$\LL$-morphism, $\LL$-embedding]
%     \link{category_of_structures}
%     The collection of all $\LL$-structures over a category $\CC$
%     forms a category
%     denoted by $\struc{\LL, \CC}$, which has objects
%     as $\LL$-structures and morphisms as $\LL$-morphisms:

%     Suppose $\MM, \NN$ are $\LL$-structures in $\CC$
%     and for each sort symbol $A$
%     we have $\io_A : \mmintp{A} \to \nnintp{A}$.
%     We say $\io := (\io_A)_{A \in \sort{\LL}}$ is
%     a \textit{$\LL$-morphism} from $\MM$ to $\NN$ when
%     \begin{itemize}
%         \item For all function symbols $f : A_1 \tdt A_n \to B$ this diagram
%         commutes:
%         \begin{cd}
%             \mmintp{A_1} \tdt \mmintp{A_n}
%             \ar[r, "\mmintp{f}"] \ar[d, "\io_{A_1} \tdt \io_{A_n}", swap]
%             & \mmintp{B} \ar[d, "\io_B"]\\
%             \nnintp{A_1} \tdt \nnintp{A_n}
%             \ar[r, "\nnintp{f}"] & \nnintp{B}
%         \end{cd}
%         \item For all relation symbols $r \hookr A_1 \tdt A_n$
%             there exists a morphism $\io_r : \mmintp{r} \to \nnintp{r}$
%             such that
%         \begin{cd}
%             \mmintp{r}
%             \ar[hookrightarrow]{r} \ar[d, "\io_r", swap]
%             & \mmintp{A_1} \tdt \mmintp{A_n}
%             \ar[d, "\io_{A_1} \tdt \io_{A_n}"]\\
%             \nnintp{r}
%             \ar[hookrightarrow]{r} & \nnintp{A_1} \tdt \nnintp{A_n}
%         \end{cd}
%     \end{itemize}
%     $\io$ is called a $\LL$-embedding (and $\NN$ a $\LL$-extension)
%     when each $\io_A$ is a monomorphism
%     and $\mmintp{r}$ is the pullback of the last diagram.
%     Restricting morphisms between objects to purely $\LL$-embeddings
%     results in a subcategory of $\struc{\LL,C}$.
% \end{dfn}
% The notion of morphisms here will be the same as that of
% morphisms in the algebraic setting.
% For example in the \linkto{dfn_grp}{language of groups},
% preserving interpretation of function symbols says
% the identity is sent to the identity, multiplication is preserved,
% and inverses are sent to inverses.

% \begin{dfn}[Interpretation of terms]
%     \link{interpretation_terms}
%     Given a $\LL$-structure $\MM$ in category $\CC$ and a $\LL$-term
%     $t : B$ with
%     $\tv{t} = \set{v_1 : A_1, \dots, v_n : A_n}$.
%     Then we can naturally interpret $t$ in the $\LL$-structure $\MM$ as a
%     morphism in $\CC$
%     \[
%         \mmintp{t} : \mmintp{A_1} \tdt \mmintp{A_n} \to \mmintp{B}
%     \]
%     that commutes with the interpretation of function symbols
%     (see proof).
%     We then refer to this map as \emph{the}
%     interpretation of the term $t$.\footnote{
%         In type theory this is can be seen as the function type
%         \[
%             \la v_1 : A_1, \dots \la v_n : A_n, \mmintp{t} :
%             \mmintp{A_1} \tdt \mmintp{A_n} \to \mmintp{B}
%         \]}

%     The following notation will be used for the interpretation of a tuple
%     of terms (which is the product of their interpretations)
%     \[
%         s = (s_1,\dots,s_n) \text{ gives us a map }\mmintp{s}
%         := \mmintp{s_1} \tdt \mmintp{s_n}
%     \]
% \end{dfn}
% \begin{proof}
%     We use the inductive definition of $t$:
%     \begin{itemize}
%         \item If $t$ is a variable $v : A$
%         then $\tv{t} = \set{v : A}$ and $t : A$.
%         Thus it makes sense to define $\mmintp{t} : \mmintp{A} \to \mmintp{A}$
%         to be the identity.
%         \item Suppose $t = f(s) : C$ for some function symbol
%         $f : B_1 \tdt B_n \to C$ and terms
%         $s : B_1 \tdt B_n$.
%         Since
%         $\tv{t} = \bigcup_{i=1}^n \tv{s_i}$
%         we must have
%         $\mmintp{t} : \prod_{x : A \in \tv{t}} \mmintp{A} \to \mmintp{C}$.
%         Induction gives each $\mmintp{s_i}$,
%         and there is naturally the map
%         \[
%             \mmintp{s} := \mmintp{s_1} \tdt \mmintp{s_n} :
%             \prod_{x : A \in \tv{t}}
%             \mmintp{A} \to \mmintp{B_1} \tdt \mmintp{B_n}
%         \]
%         so we define the interpretation of $t$
%         to be the composition $\mmintp{t} := \mmintp{f} \circ \mmintp{s}$.
%     \end{itemize}
% \end{proof}
% Note that for constant symbols the interpretation has the empty product
% - a `singleton' - as its domain hence is a constant map -
% an `element' of the interpreted sort.

% \begin{eg}
%     Following the \linkto{terms_as_polys_example}{previous example},
%     in the language of rings
%     \linkto{terms_in_RNG_are_polynomials}{terms will be multivariable
%         integer polynomials}
%     and then terms interpreted in some structure - say a ring $A$ -
%     are then multivariable integer polynomial functions
%     $A^n \to A$.
% \end{eg}

% The following is exactly what we expect - that terms are well behaved
% with respect to morphisms.
% \begin{prop}[$\LL$-morphisms commute with interpretation of terms]
%     \link{morph_comm_term_intp}
%     Given a $\LL$-morphism $\io : \MM \to \NN$,
%     we have that for any $\LL$-term $t$
%     with $\tv{t} = \set{v_1 : A_1, \dots, v_n : A_n}$
%     this diagram commutes
%     \begin{cd}
%         \mmintp{A_1} \tdt \mmintp{A_n} \ar[r, "\mmintp{t}"]
%         \ar[d, "\io_{A_1} \tdt \io_{A_n}", swap] &
%         \mmintp{B} \ar[d, "\io_B"]\\
%         \nnintp{A_1} \tdt \nnintp{A_n} \ar[r, "\nnintp{t}"]
%         &
%         \nnintp{B}
%     \end{cd}
% \end{prop}
% \begin{proof}
%     We case on what $t$ is:
%     \begin{itemize}
%         \item If $t$ is a variable $v : A$ then
%         $\mmintp{t} = \id{\mmintp{A}}$ and $\nnintp{t} = \id{\nnintp{A}}$
%         hence the following commutes
%         \begin{cd}
%             \mmintp{A}  \ar[r, "\mmintp{t}"]
%             \ar[d, "\io_{A}", swap] &
%             \mmintp{A} \ar[d, "\io_A"]\\
%             \nnintp{A} \ar[r, "\nnintp{t}"]
%             &
%             \nnintp{A}
%         \end{cd}
%         \item Suppose $t = f(s) : C$ for some function symbol
%         $f : B_1 \tdt B_n \to C$ and terms
%         $s : B_1 \tdt B_n$.
%         We consider the diagram
%         \begin{cd}
%             {\prod_{x : A \in \tv{t}}\mmintp{A}} & {} & {\mmintp{B}} \\
%             & {\mmintp{B_1}\tdt \mmintp{B_n}} \\
%             {\prod_{x : A \in \tv{t}}\nnintp{A}} && {\nnintp{B}} \\
%             & {\nnintp{B_1}\tdt \nnintp{B_n}}
%             \ar["{\mmintp{t}}", from=1-1, to=1-3]
%             \ar["{\nnintp{t}}"{description, pos=0.2}, from=3-1, to=3-3]
%             \ar["{\prod\io_A}", from=1-1, to=3-1, swap]
%             \ar[
%                 "{\mmintp{s_1}\tdt \mmintp{s_n}}"{description},
%                 from=1-1, to=2-2]
%             \ar[
%                 "{\nnintp{s_1}\tdt \nnintp{s_n}}"{description}, from=3-1,
%                 to=4-2]
%             \ar["{\nnintp{f}}"{description}, from=4-2, to=3-3]
%             \ar["{\mmintp{f}}"{description}, from=2-2, to=1-3]
%             \ar[
%                 "{\io_{B_1} \tdt \io_{B_n}}"{description, pos=0.2},
%                 from=2-2, to=4-2, crossing over]
%             \ar["{\io_B}", from=1-3, to=3-3]
%         \end{cd}
%         Induction gives that the left face commutes and the definition
%         of interpretation gives us that the top and bottom faces commute.
%         By definition of interpretation of function
%         symbols the right face commutes.
%         From this we can deduce that the background of the following diagram
%         commutes, as required.
%     \end{itemize}
% \end{proof}

% \begin{dfn}[Models in different languages]
%     \link{move_down_mod_0}
%     Given two languages
%     $\LL \leq \LL^*$ and
%     a $\LL^*$-structure $\MM$ is naturally a $\LL$-structure $\NN$ such that
%     $\subintp{\LL}{\MM}{\star} = \subintp{\LL^*}{\NN}{\star}$.
%     We will often just write $\MM$ to mean either.
% \end{dfn}

% \begin{prop}[Morphisms in different languages]
%     \link{morph_diff_sigs}
%     Suppose $\LL \leq \LL^*$
%     and we have $\LL^*$-structures $\MM$ and $\NN$
%     (\linkto{move_down_mod_0}{naturally $\LL$-structures}).
%     If $\io : \MM \to \NN$ is a morphism in $\CC$ then
%     $\io$ is a $\LL$-morphism if and only if it is a $\LL^*$-morphism, and
%     an embedding in $\LL$ if and only if in $\LL^*$.
% \end{prop}
% \begin{proof}
%     If $f : \prod A \to B$ is a function symbol
%     then $\prod \subintp{\LL}{\MM}{A} = \prod \subintp{\LL^*}{\MM}{A}$
%     and $\subintp{\LL}{\MM}{B} = \subintp{\LL^*}{\MM}{B}$
%     (similarly for $\NN$).
%     Hence the commuting diagram is the same diagram.
%     Similarly the commuting diagram is the same for any relation symbol.
%     Giving us the result.
% \end{proof}

% \subsection{Formulas in classical first order logic}
% From this point onwards we will work in classical first order logic.

% \begin{dfn}[Atomic formula, quantifier free formula]
%     Given $\LL$ a language,
%     its set of atomic $\LL$-formulas along with their
%     associated set of typed free variables $\tv{\star}$ is defined by
%     \begin{itemize}
%         \item[$\vert$] $\top$ is an atomic $\LL$-formula
%         with no typed free variables $\tv{\top} = \nothing$.
%         \item[$\vert$]
%         Given $t, s \in \term{\LL}$ of the same type,
%         the string $t = s$ is an atomic $\LL$-formula.
%         The set of typed free variables is
%         $\tv{t = s} = \tv{t} \cup \tv{s}$.
%         \item[$\vert$] Given $r \in \rel{\LL}$ such that
%         $r \hookr A_1 \times \dots A_n$ and $t : A_1 \times \dots \times A_n$,
%         the string $r(t)$ is an atomic $\LL$-formula.
%         The typed free variables are $\tv{r(t)} = \bigcup_{i = 1}^n \tv{t_i}$.
%     \end{itemize}

%     We extend this to the set of quantifier free $\LL$-formulas inductively:
%     \begin{itemize}
%         \item[$\vert$] Given $\phi$ an atomic $\LL$-formula,
%             $\phi$ is a quantifier free $\LL$-formula.
%         \item[$\vert$] Given $\phi$ a quantifier free $\LL$-formula,
%         the string $\NOT \phi$ is a quantifier free $\LL$-formula with the
%         same set of typed free variables as $\phi$.
%         \item[$\vert$] Given $\phi, \psi$ both quantifier free $\LL$-formulas,
%         the string $\phi \OR \psi$ is a quantifier free $\LL$-formula.
%         The set of typed free variables is
%         $\tv{\phi \OR \psi} = \tv{\phi} \cup \tv{\psi}$.
%     \end{itemize}

%     The set of all $\LL$-formulas $\form{\LL}$
%     is defined by extending the above:
%     \begin{itemize}
%         \item[$\vert$] Given $\phi$ a quantifier free $\LL$-formula,
%         $\phi$ is a $\LL$-formula.
%         \item[$\vert$] Given $\phi \in \form{\LL}$, a sort $A$
%         and a variable $v : A$, we take the string $\forall v : A, \phi$ and
%         replace all occurrences of
%         $v$ with an unused symbol
%         $z \in \var{A}$,
%         producing a new a $\LL$-formula $\psi = \forall z : A, \phi$.
%         The set of typed free variables is
%         $\tv{\psi} = \tv{\phi} \setminus \set{v : A}$.
%     \end{itemize}
%     Shorthand for some $\LL$-formulas include
%     \begin{itemize}
%         \item $\bot := \NOT \top$
%         \item $\phi \land \psi := \NOT((\NOT\phi) \lor (\NOT\psi))$
%         \item $\phi \to \psi := (\NOT\phi) \lor \psi$
%         \item $\exists v : A, \phi := \NOT(\forall v : A, \NOT\phi)$
%     \end{itemize}

%     The symbol $z$ is thought of as a `bounded variable' as oppose to
%     a `free variable',
%     and will not be considered when we want to evaluate
%     variables in formulas.

%     Often we will be in 1-sorted languages,
%     in which case we will just write
%     \[
%         \forall v, \phi \text{ and } \exists v, \phi
%     \]
%     since the type is obvious.
% \end{dfn}
% \begin{rmk}
%     Formulas should be thought of as propositions with some bits loose,
%     namely the free variables, since it does not make any sense to ask if
%     $x = a$ without saying what $x$ you are taking
%     (where $x$ is a variable as $a$ is a constant symbol, say).
%     When there are no free variables we get what intuitively looks like a
%     proposition, and we will call these particular formulas \linkto{sentences}{sentences}.
% \end{rmk}

% \begin{dfn}[Substituting in terms]
%     If a $\LL$-formula $\phi$ has a typed free variable $v : A$
%     then to remind ourselves of the variable we can write
%     $\phi = \phi(v : A) = \phi(v)$ instead.

%     If we have term $t : A$ for some typed free variable $v : A$
%     in $\tv{\phi}$,
%     then we write $\phi(t)$ to mean $\phi(v : A)$ with
%     $t$ substituted for $v$.
%     By induction on terms and formulas this is still a
%     $\LL$-formula and has
%     \[\tv{\phi(t)} = \tv{t} \cup \brkt{\tv{\phi(v)} \setminus \set{v : A}}\]
% \end{dfn}

% \subsection{Classical models, theories}
% From now on we will be interpreting only in the category $* / \SET$
% of non-empty sets.
% We require non-emptiness because the classical proof of compactness,
% given by a \linkto{make_wit}{Henkin construction}
% relies on non-emptiness of our models.

% \begin{dfn}[Satisfaction]
%     Let $\MM$ be a $\LL$-structure (interpreted in $* / \SET$
%     and $\phi$ a $\LL$-formula.
%     Let $a \in \prod_{x : A \in \tv{\phi}} \mmintp{A}$ be a tuple indexed by
%     the typed free variables of $\phi$.
%     Then we define $\MM \modelsi \phi(a)$ by induction on formulas:
%     \begin{itemize}
%         \item If $\phi$ is $\top$ then $\MM \model{\LL} \phi$.\footnote{
%             We can omit the $a$ when there are no free variables.
%             Formally $a$ is the unique element in the empty product.}
%         \item If $\phi$ is $t = s$ then
%             $\MM \model{\LL} \phi(a)$ when
%             $\modintp{\MM}{t}(a) = \modintp{\MM}{s}(a)$.
%             \item If $\phi$ is $r(t)$,
%             where $r \hookr A_1 \tdt A_n$ is a relation symbol and
%             $t : A_1 \tdt A_n$ are terms,
%             then $\MM \model{\LL} \phi(a)$ when
%             $\modintp{\MM}{t}(a) \in \modintp{\MM}{r}$.\footnote{
%             $\modintp{\MM}{t}$ was the
%             \linkto{interpretation_terms}{product of interpreted terms}.
%             }
%             \vspace{1em}
%         \item If $\phi$ is
%             $\NOT\psi$ for some $\psi \in \form{\LL}$,
%             then $\MM \model{\LL} \phi(a)$ when $\MM \nodel{\LL} \psi(a)$
%         \item If $\phi$ is  $\psi \lor \chi$,
%             then $\MM \model{\LL} \phi(a)$ when
%             $\MM \model{\LL} \psi(a)$ or $\MM \model{\LL} \chi(a)$.
%         \item If $\phi$ is
%             $\forall v : A, \psi$,
%             then $\MM \model{\LL} \phi(a)$
%             if for any $b \in \mmintp{A}$,
%             $\MM \model{\LL} \psi(a,b)$.
%     \end{itemize}
% \end{dfn}

% \begin{rmk}
%     Any $\LL$-structure satisfies $\top$
%     and does not satisfy $\bot$.
%     Note that for $c$ a tuple of constant symbols
%     $\MM \model{\LL} \phi(c)$ if and only if
%     $\MM \model{\LL} \phi(\mmintp{c})$.
% \end{rmk}

% \begin{dfn}[Sentences and theories]
%     \link{sentences}
%     Let $\LL$ be a language and $\phi$ a $\LL$-formula.
%     We say $\phi \in \form{\LL}$ is a $\LL$-sentence when
%     it has no free variables, $\tv{\phi} = \nothing$.

%     $T$ is an $\LL$-theory when it is a subset of $\form{\LL}$
%     such that all elements of $T$ are $\LL$-sentences.
%     We denote the set of $\LL$-theories as $\theory{\LL}$.
% \end{dfn}

% \begin{dfn}[Models]
%     Given an $\LL$-structure $\MM$ and $\LL$-theory $T$,
%     we write $\MM \model{\LL} T$ and say
%     \emph{$\MM$ is a $\LL$-model of $T$} when
%     for all $\phi \in T$ we have $\MM \model{\LL} \phi$.
% \end{dfn}

% \begin{eg}
%     In the language of rings,
%     \linkto{dfn_rings}{the rings axioms} will be the theory
%     of rings and each model of the theory will consist of a single sort - the ring.
%     The %?\linkto{missing_link}{
%     theory of $\ZFC$ %} %? MISSING LINK
%     consists of the $\ZFC$ axioms and a model of $\ZFC$
%     would be a single sort thought of as the `class of all sets'.
%     In the language of modules,
%     \linkto{dfn_modules}{the theory of modules} will consist of the theory for rings,
%     the theory for commutative groups, and the axioms for modules over a ring.
%     A model of the theory of modules would consist of two sorts,
%     one for the ring and one for the module.
% \end{eg}

% \begin{dfn}[Consequence]
%     Given a $\LL$-theory $T$
%     and a $\LL$-sentence $\phi$,
%     we say $\phi$ is a consequence of $T$
%     and say $T \model{\LL} \phi$
%     when for all $\LL$-models $\MM$ of $T$,
%     we have $\MM \model{\LL} \phi$.
%     We also write $T \model{\LL} \De$
%     for $\LL$-theories $T$ and $\De$
%     when for every $\phi \in \De$ we have $T \model{\LL} \phi$.
% \end{dfn}

% \begin{ex}[Logical consequence]
%     Let $T$ be a $\LL$-theory and $\phi$ and $\psi$ be $\LL$-sentences.
%     Show that the following are equivalent:
%     \begin{itemize}
%         \item $T \model{\LL} \phi \to \psi$
%         \item $T \model{\LL} \phi$ implies $T \model{\LL} \psi$.
%     \end{itemize}
% \end{ex}

% \begin{dfn}[Consistent theory]
%     \link{consistent}
%     A $\LL$-theory $T$ is consistent if either of the following equivalent
%     definitions hold:
%     \begin{itemize}
%         \item
%             There does not exists a
%             $\LL$-sentence $\phi$ such that
%             $T \model{\LL} \phi$ and $T \model{\LL} \NOT \phi$.
%         \item There exists
%             a $\LL$-model of $T$.
%     \end{itemize}
%     Thus the definition of consistent is intuitively
%     `$T$ does not lead to a contradiction'.
%     A theory $T$ is finitely consistent if all
%     finite subsets of $T$ are consistent.
%     This will turn out to be another equivalent definition,
%     given by the \linkto{compactness}{compactness theorem}.
% \end{dfn}
% \begin{proof}
%     We show that the two definitions are equivalent.
%     \begin{forward}
%         Suppose no model exists.
%         Take $\phi$ to be the $\LL$-sentence $\top$.
%         Hence all $\LL$-models of $T$ satisfy $\top$ and $\bot$
%         (there are none) so
%         $T \model{\LL} \top$ and $T \model{\LL} \bot$.
%     \end{forward}
%     \begin{backward}
%         Suppose $T$ has a $\LL$-model $\MM$
%         and $T \model{\LL} \phi$ and $T \model{\LL} \NOT \phi$.
%         This implies $\MM \model{\LL} \phi$ and $\MM \nodel{\LL} \phi$,
%         a contradiction.
%     \end{backward}
% \end{proof}

% \begin{dfn}[Elementary equivalence]
%     Let $\MM$, $\NN$ be $\LL$-structures.
%     They are elementarily equivalent if for any $\LL$-sentence $\phi$,
%     $\MM \model{\LL} \phi$ if and only if $\NN \model{\LL} \phi$.
%     We write $\MM \equiv_\LL \NN$.
% \end{dfn}

% \begin{dfn}[Maximal and complete theories]
%     \link{equiv_def_completeness_0}
%     A $\LL$-theory $T$ is \textit{maximal} if
%     for any $\LL$-sentence $\phi$,
%     $\phi \in T$ or $\NOT \phi \in T$.

%     $T$ is \textit{complete}
%     when either of the following equivalent
%     definitions hold:
%     \begin{itemize}
%         \item For any $\LL$-sentence $\phi$,
%             $T \model{\LL} \phi$ or
%             $T \model{\LL} \NOT \phi$.
%         \item All models of $T$ are elementarily equivalent.
%     \end{itemize}
%     Note that maximal theories are complete.
% \end{dfn}
% \begin{proof}
%     \begin{forward}
%         Let $\MM$ and $\NN$ be models of $T$
%         and $\phi$ be a $\LL$-sentence.
%         If $T \model{\LL} \phi$ then both satisfy $\phi$.
%         Otherwise $\NOT \phi \in T$ and neither satisfy $\phi$.
%     \end{forward}

%     \begin{backward}
%         If $\phi$ is a $\LL$-sentence then suppose for a contradiction
%         \[T \nodel{\LL} \phi \text{ and } T \nodel{\LL} \NOT \phi\]
%         Then there exist models of $T$
%         such that $\MM \nodel{\LL} \phi$ and $\NN \nodel{\LL} \NOT \phi$.
%         By assumption they are elementarily equivalent and so
%         $\MM \model{\LL} \NOT \phi$ implies $\NN \model{\LL} \NOT \phi$,
%         a contradiction.
%     \end{backward}
% \end{proof}

% \begin{ex}[Not consistent, not complete]
%     \link{not_consequence}
%     Let $T$ be a $\LL$-theory
%     and $\phi$ is a $\LL$-sentence.
%     Show that $T \nodel{\LL} \phi$
%     if and only if $T \cup \set{ \NOT \phi}$ is consistent.
%     Furthermore, $T \nodel{\LL} \NOT \phi$
%     if and only if $T \cup \set{\phi}$ is consistent.

%     Note that by definition for $\LL$-structures and
%     $\LL$-formulas we (classically) have that
%     \[
%         \MM \modelsi \NOT \phi(a) \iff \MM \nodelsi \phi(a)
%     \]
%     Find examples of theories that do not satisfy
%     \[
%         T \modelsi \NOT \phi \iff T \nodelsi \phi
%     \]
% \end{ex}
