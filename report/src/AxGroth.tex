It is a basic fact of linear algebra that any linear map
between vector spaces of the same finite dimension is
injective if and only if it is surjective.
\linkto{ax_groth_thm}{Ax-Grothendieck} says that this is
partly true for polynomial maps.

\begin{dfn}[Polynomial maps]
  \link{dfn_poly_map}
  Let $K$ be a commutative ring and $n$ a natural
  (we use $K$ since we are only interested in the case
  when it is an algebraically closed field).
  Let $f : K^n \to K^n$ such that for each $a \in K^n$,
  \[f(a) = (f_1(a), \dots, f_n(a))\] for
  $f_1, \dots, f_n \in K[x_1, \dots, x_n]$.
  Then we call $f$ a polynomial map over $K$.

  For the sake of computation it is simpler to simply assert
  the data of the $n$ polynomials directly:

  \begin{lstlisting}
  def poly_map (K : Type*) [comm_semiring K] (n : ℕ) : Type* :=
  fin n → mv_polynomial (fin n) K \end{lstlisting}

  Then we can take the map on types/sets by evaluating each polynomial
  \begin{lstlisting}
  def eval : poly_map K n → (fin n → K) → (fin n → K) :=
  λ ps as k, mv_polynomial.eval as (ps k) \end{lstlisting}
\end{dfn}

\begin{prop}[Ax-Grothendieck]
    \link{ax_groth_thm}
    Any injective polynomial map over an algebraically closed field is surjective.
    In particular injective polynomial maps over $\C$ are surjective.

\begin{lstlisting}
  theorem Ax_Groth {n : ℕ} {ps : poly_map K n} (hinj : function.injective (poly_map.eval ps)) :
  function.surjective (poly_map.eval ps) := sorry \end{lstlisting}
\end{prop}

The key lemma to prove this is the \linkto{lefschetz}{Lefschetz principle},
which says that ring theoretic statements are true in instances of algebraically closed fields
if and only if they are true in all algebraically closed fields
(assuming zero or large enough prime characteristic).
Lefschetz will be stated and proven in a later section.

An overview of the proof of Ax-Grothendieck follows:

\begin{itemize}
  \item We want to reduce the statement of Ax-Grothendieck to a model-theoretic one.
        Then we can apply the \linkto{lefschetz}{Lefschetz principle} to
        reduce to the prime characteristic case.
  \item To express ``for any polynomial map ...'' model-theoretically,
        which amounts to somehow quantifying over all polynomials
        in $n$ variables,
        we bound the degrees of all the polynomials,
        i.e. asking instead ``for any polynomial map consisting of
        polynomials with degree at most $d$''.
        Then we can write the polynomial as a sum of its monomials,
        with the coefficients as bounded variables.
  \item We express injectivity and surjectivity model-theoretically,
        and prove internal completeness and soundness for these statements.
  \item We apply Lefschetz, so that it suffices to prove Ax-Grothendieck for
        algebraic closures of a finite fields.
\end{itemize}

\subsection{Stating Ax-Grothendieck model-theoretically}

Our first objective is to state Ax-Grothendieck model-theoretically.
Let us assume we have an $n$-variable polynomial $p \in K[x_{1},\dots,x_{n}]$.
We know that $p$ can be written as a sum of its monomials,
and the set of monomials \texttt{monom\_deg\_le n d} is finite,
depending on the degree $d$ of the polynomial $p$.
It can be indexed by

\[ \texttt{monom\_deg\_le\_finset n d} := \set{ f : \texttt{fin n} \to \N \st \sum_{i < n} f i \le d }\]

Then we write
\[ p = \sum_{f\texttt{ : monom\_deg\_le n d}} p_{f}\prod_{i < n} x^{f i}\]

The typical approach to writing a sum like this in lean would be
to tell lean that only finitely many of the $p_{f}$ are non-zero
($p_{\star}$ is finitely supported - \texttt{finsupp}).
However, the API built for this assumes that the underlying
type in which the sum takes place is a commutative monoid,
which is not the case here,
as we will be expressing the above as a sum of terms
in the language of rings.
This type has addition and multiplication and so on,
which we supplied as \linkto{lean_symbols_for_ring_symbols}{instances} already,
but these are neither commutative nor associative.
Thus the workaround here was to use \texttt{list.sumr}
(my own definition, similar to \texttt{list.sum}) instead,
which will take a list of terms in the language of rings, and sum them together.

The below definition is meant to (re)construct polynomials as described above,
using free variables to represent the coefficients of some polynomial.
This can then be used to express injectivity and surjectivity.

\begin{lstlisting}
def poly_indexed_by_monoms (n d s p c : ℕ)
  (hndsc : (monom_deg_le n d).length + s ≤ c)
  (hnpc : n + p ≤ c) :
  bounded_ring_term c :=
list.sumr
(list.map
  (
    λ f : (fin n → ℕ),
    let
      x_js : bounded_ring_term c :=
      x_ ⟨((monom_deg_le n d).index_of' f + s) , ... ⟩,
      x_ip (i : fin n) : bounded_ring_term c :=
      x_ ⟨ (i : ℕ) + p , ... ⟩
    in
    x_js * (n.non_comm_prod (λ i, npow_rec (f i) (x_ip i)))
  )
  (monom_deg_le n d)
) \end{lstlisting}

To explain the above, we wish to express the ring term with $c$ many free variables
(``in context $c$'')
\[\sum_{f \in \texttt{monom\_deg\_le n d}} x_{j+s} \prod_{0 \le i < n} x_{i+p}^{f(i)}\]
\begin{itemize}
  \item When we write \texttt{x\_ < n , ... >} we are giving a natural $n$
        and a proof that $n$ is less than the context/variable bound $c$,
        which we omit here.
  \item \texttt{list.map} takes the list \texttt{monom\_deg\_le n d}
        (which is just \texttt{monom\_deg\_le\_finset n d} as a list instead\footnote{
          This uses the axiom of choice, in the form of \texttt{finset.to\_list}.})
        and gives us a list of terms looking like
        \[x_{js} \prod_{i < n} (x_{ip} i) ^{f i}\] one for each
        $f \in \texttt{monom\_deg\_le\_finset n d}$.
  \item Then \texttt{list.sumr} sums these terms together,
        producing a term in $c$ many free variables representing a polynomial.
  \item To define \texttt{x\_js} we take the index of $f$ in the list that $f$ came from
        and we add $s$ at the end and take the variable $x_{\texttt{index f} + s}$.
  \item To make the product we use \texttt{non\_comm\_prod}
        (this makes products indexed by \texttt{fin n},
        and works without commutativity or associativity conditions).
        For each $i < n$ we multiply together $x_{i + p}$.
  \item The purpose of adding $s$ and $p$ is to ensure we are not repeating variables in
        this expression. They give us control of where the variables begin and end.

        In the two situations where these polynomials are used $p$ is taken to be
        either $0$ or $n$; this makes the realizing variables $x_{0},\dots,x_{n - 1}$
        or $x_{n}, \dots, x_{2n - 1}$ represent evaluating the polynomials at values
        assigned to $x_{0},\dots,x_{2n - 1}$.

        The value $s$ in both instances taken to be
        $j \times \abs{\texttt{monom\_deg\_le\_finset n d}} + 2n$, where
        $j$ will represent the $j$-th polynomial
        (out of the $n$ polynomials from \texttt{poly\_map\_data}).
        This ensures that the variables between different polynomials
        in our polynomial map don't overlap.
\end{itemize}

\subsubsection*{Injectivity and surjectivity}

We can then express injectivity of a polynomial map.

\begin{lstlisting}
def inj_formula (n d : ℕ) :
  bounded_ring_formula (n * (monom_deg_le n d).length) :=
let monom := (monom_deg_le n d).length in
-- for all pairs in the domain x₋ ∈ Kⁿ and ...
bd_alls' n _
$
-- ... y₋ ∈ Kⁿ
bd_alls' n _
$
-- if at each pⱼ
(bd_big_and n
-- pⱼ x₋ = pⱼ y₋
  (λ j,
    (poly_indexed_by_monoms n d (j * monom + n + n) n _ _ ) -- note n
    ≃
    (poly_indexed_by_monoms n d (j * monom + n + n) 0 _ _ ) -- note 0
  )
)
-- then
⟹
-- at each 0 ≤ i < n,
(bd_big_and n ( λ i,
-- xᵢ = yᵢ (where yᵢ is written as xᵢ₊ₙ₊₁)
  x_ ⟨ i + n , ... ⟩ ≃ x_ (⟨ i , ... ⟩)
))
\end{lstlisting}

To explain the above, suppose we have $p$ the data of a polynomial map
(i.e. for each $j < n$ we have $p_j$ a polynomial).
We wish to express ``for all $x,y \in K^{n}$,
if $p x = p y$ then $x = y$''.
\begin{itemize}
  \item \texttt{bd\_alls' n} adds $n$ many $\forall$s in front of the
        formula coming after.
        The first represents $x = (x_{n},\dots,x_{2n-1})$ and the second represents
        $y = (y_{0},\dots,y_{n-1}) = (x_{0},\dots,x_{n-1})$.
        We choose this ordering since when we quantify this expression
        we first introduce $x$, which is of a higher index.
  \item \texttt{bd\_big\_and n} takes $n$ many formulas and places $\AND$s between
        each of them. In particular it expresses $p x = p y$, by breaking this up
        into the data of ``for each $j < n$, $p_{j} x = p_{j} y$'',
        as well as $x = y$, by breaking this up into the data of ``for each $i < n$,
        $x_{i+n} = x_{i}$''
  \item To write $p_{j} x$ and $p_{j} y$ we simply find the right variable indices
        to supply \texttt{poly\_indexed\_by\_monoms},
        and we ask for them to be equal.
\end{itemize}

Surjectivity is similar

\begin{lstlisting}
def surj_formula (n d : ℕ) :
  bounded_ring_formula (n * (monom_deg_le n d).length) :=
let monom := (monom_deg_le n d).length in
-- for all x₋ ∈ Kⁿ in the codomain
bd_alls' n _
$
-- there exists y₋ ∈ Kⁿ in the domain such that
bd_exs' n _
$
-- at each 0 ≤ j < n
bd_big_and n
-- pⱼ y₋ = xⱼ
λ j,
  poly_indexed_by_monoms n d (j * monom + n + n) 0 _
    inj_formula_aux0 inj_formula_aux1
  ≃
  x_ ⟨ j + n , ... ⟩ \end{lstlisting}

We wish to express ``for all $x \in K^{n}$, there exists $y \in K^{n}$ such that $p y = x$''.
Just like \texttt{bd\_alls' n}, \texttt{bd\_exs' n} adds $n$ many $\ex$s in front of the
formula coming after.

%% The statement of Ax-Groth in lean
