\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{cochineal}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{tikz-cd}
\usepackage{adjustbox}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}
\definecolor{mono}{RGB}{150,100,100}


% % Set the monospace font
\usepackage{inconsolata}

% % Monospace colour
\newcommand{\code}[1]{\texttt{\color{mono}#1}}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
\newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

\newenvironment{dfn}{
  \textbf{Definition} \,

}{\newline}


\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\title{Ax-Grothendieck in lean}
\subtitle{Joseph Hua}
\date{\today}
% \author{}
\institute{Imperial College London}
% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}

\maketitle

\section{Motivation}

\begin{frame}[fragile]{Polynomial maps}

  \begin{definition}[Polynomial maps]
    \link{poly_map}
    Polynomial maps on a field $K$ are regular endomorphisms on $K^{n}$,
    i.e. $n$ polynomials in $K[x_1,\dots,x_{n}]$.
  \end{definition}

  \pause

  \textbf{Examples}

  \begin{itemize}
    \item <2-> Surjective but not injective: $f : \C \to \C := x \mapsto x^{2}$

    \item <3-> Neither surjective nor injective:
          $f : \C^{2} \to \C^{2} := (x,y) \mapsto (x,xy)$
    \item <4-> Bijective:
          $f : \C^{3} \to \C^{3} := (x,y,z) \mapsto ( x , y , z + xy )$
    \item <5-> Bijective $f : \bar{\F_{2}} \to \bar{\F_{2}}  := x \mapsto x^{2}$
    \item <6-> Surjective but not injective $f : \bar{\F_{3}} \to \bar{\F_{3}} := x \mapsto x^{2}$
  \end{itemize}
  % \pause \pause \pause

  % \textbf{Code}

  % \begin{lstlisting}
  % def poly_map (K : Type*) [comm_semiring K] (n : ℕ) : Type* :=
  % fin n → mv_polynomial (fin n) K

  % def eval : poly_map K n → (fin n → K) → (fin n → K) :=
  % λ ps as k, mv_polynomial.eval as (ps k) \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Ax-Grothendieck}

  \begin{theorem}[Ax-Grothendieck]
    \link{ax_groth}
    Any injective polynomial map over an algebraically closed field is surjective.
    In particular injective polynomial maps over $\C$ are surjective.

  \end{theorem}

%   \pause

% \begin{lstlisting}
%   theorem Ax_Groth {n : ℕ} {ps : poly_map K n}
%     (hinj : function.injective (poly_map.eval ps)) :
%   function.surjective (poly_map.eval ps) := sorry \end{lstlisting}

  \pause

\begin{itemize}[<+->]
  \item Amazing fact (Lefschetz): true for a single algebraically closed field of characteristic $n$
        (a model of $\ACF_{n}$)
        $\to$ true for any model of $\ACF_{n}$ ($n$ is zero or prime).
  \item Amazing fact (Lefschetz): true for $\ACF_{p}$ for all large prime $p$ $\to$ true for $\ACF_{0}$.
  \item Good news: We can easily show it for algebraic closures of finite fields.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Locally finite fields}
  \begin{definition}[Locally finite fields]
    \link{locally_finite}
    Let $K$ be a field of characteristic $p$ a prime.
    Then the following are equivalent definitions for $K$ being a
    \textit{locally finite field}:
    \begin{enumerate}[<+->]
        \item The minimal subfield generated by any finite subset of $K$ is finite.
        \item $\F_p \to K$ is algebraic.
        \item $K$ embeds into an algebraic closure of $\F_p$.
    \end{enumerate}
\end{definition}
\visible<4>{\begin{theorem}
  \link{ax_groth_local}
  Locally finite fields satisfy Ax-Grothendieck.
\end{theorem}
\begin{proof}
  \[ \F_{p} \hookr \F_{p}(\code{coeffs}) \hookr K\]
  \[ \downarrow_{\F_{p}(\code{coeffs})} \text{ respects injectivity }\]
\end{proof}}
\end{frame}

% \begin{frame}[fragile]{Locally finite fields}
% \begin{lstlisting}
%   lemma Ax_Groth_of_locally_finite (K₀ : Type*) {L : Type*}
%     [field K₀] [fintype K₀] [comm_ring L] [algebra K₀ L] (alg : algebra.is_algebraic K₀ L)
%     (n) (ps : poly_map L n) (hinj : function.injective (poly_map.eval ps)) :
%     function.surjective (poly_map.eval ps) := sorry \end{lstlisting}
% \end{frame}


\begin{frame}[fragile]{The Lefschetz principle}
  \begin{theorem}[Lefschetz principle]
    \link{lefschetz}
    Let $\phi$ be a sentence in the language of rings. % EXAMPLE = exists x ≠ y , x^2 + x + 1 = 0 ∧ y^2 + y + 1 = 0
    Then the following are equivalent:
    \begin{enumerate}[<+->]
        \item Some model of $\ACF_0$ satisfies $\phi$.
        (If you like $\C \vDash \phi$.)
        \item $\ACF_0 \vDash \phi$
        \item There exists $n \in \N$ such that for any prime $p$
            greater than $n$, $\ACF_p \vDash \phi$
        \item There exists $n \in \N$ such that for any prime $p$
        greater than $n$, some model of $\ACF_p$ satisfies $\phi$.
    \end{enumerate}
    % ($1. \IFF 2.$) and ($3. \IFF 4.$) are due to the theories $\ACF_{p}$
    % being complete for any $p$ ($0$ or prime);
    % ($2. \IFF 3.$) due to compactness theorem.
\end{theorem}
\end{frame}

\section{Model Theory}

\begin{frame}[fragile]{Languages}
% \begin{columns}
%     \begin{column}{0.3\textwidth}
\adjustbox{{scale=1}}{%
\begin{lstlisting}
structure Language : Type (u+1) :=
  (functions : ℕ → Type u)
  (relations : ℕ → Type u) \end{lstlisting}
}
\vspace{1 em}

\pause

% \begin{column}{0.8\textwidth}<2->
  \begin{definition}[Language of rings]
    \link{dfn_rings}
        Let the following be the language of rings:
    \begin{itemize}
        \item The function symbols are the constant symbols $0, 1$,
        $+ , \times$ for addition and multiplication
        and $-$ for taking additive inverse.
        \item There are no relation symbols.
    \end{itemize}
  \end{definition}
% \end{column}
% \end{columns}

\pause

\textbf{More examples}

\begin{itemize}
  \item Language of groups
  \item Language of monoid actions from a monoid $M$
        and modules on a ring $A$
  \item Single binary relations
\end{itemize}

% \end{column}
\end{frame}


\begin{frame}[fragile]{Terms and formulas}

  Terms are ``free algebraic expressions'' on some number of variables,
  i.e. sensible combinations of variable and function symbols.
  \begin{itemize}[<+->]
    \item Terms with $n$ variables in the language of rings
          can be interpreted as elements of $\Z[x_{1},\dots,x_{n}]$
          (this will identify $x_{1} + x_{2}$ and $x_{2} + x_{1}$,
          which are \textit{distinct terms}).
    \item Terms with $n$ variables in the language of groups
          can be interpreted as elements of the free group on
          $\set{x_{1},\dots,x_{n}}$.
    \item Terms with $n$ variables in the language of modules
          over a ring $A$ can be interpreted as
          elements of the free module $A^{\oplus n}$.
    \item Terms with $n$ variables in the language of binary relations is
          just the set $\set{x_{1},\dots,x_{n}}$.
  \end{itemize}


  % \adjustbox{{scale=0.8}}{%
% \begin{lstlisting}
% inductive bounded_preterm (n : ℕ) : ℕ → Type u
%   | x_ : ∀ (k : fin n), bounded_preterm 0
%   | bd_func : ∀ {l : ℕ} (f : L.functions l), bounded_preterm l
%   | bd_app : ∀ {l : ℕ} (t : bounded_preterm (l + 1))
%       (s : bounded_preterm 0), bounded_preterm l

%  def bounded_term (n : ℕ) := bounded_preterm L n 0\end{lstlisting}
% %}

%   \[
%   x_{1} * 0 \rightsquigarrow \code{bd\_app (bd\_app (bd\_func mul) (x\_ 1)) (bd\_func zero)}
%   \]


% \adjustbox{scale=0.8,center}{%
%   \begin{lstlisting}
%     inductive bounded_preformula : ℕ → ℕ → Type u
%     | bd_falsum {n : ℕ} : bounded_preformula n 0
%     | bd_equal {n : ℕ} (t₁ t₂ : bounded_term L n) : bounded_preformula n 0
%     | bd_rel {n l : ℕ} (R : L.relations l) : bounded_preformula n l
%     | bd_apprel {n l : ℕ} (f : bounded_preformula n (l + 1)) (t : bounded_term L n) : bounded_preformula n l
%     | bd_imp {n : ℕ} (f₁ f₂ : bounded_preformula n 0) : bounded_preformula n 0
%     | bd_all {n : ℕ} (f : bounded_preformula (n+1) 0) : bounded_preformula n 0

%     def bounded_formula (n : ℕ) := bounded_preformula L n 0
%     def sentence := bounded_preformula L 0 0\end{lstlisting}
% }
% \[ \forall x_{2} \, x_{1} \, x_{0} : A, \exists x_{3} : A, x_{0} x_{3}^{2} + x_{1} x_{3} + x_{2} = 0 \]
\end{frame}

\begin{frame}[fragile]{Terms and formulas}

  Formulas are logical combinations of terms, equality,
  (and other relation symbols from the language if there are any).
  \begin{itemize}[<+->]
    \item[]
          \[ x_{0}^{2} + 2 x_{1} + 1 = x_{2} \]
    \item[] \[ x_{0}^{2} + 2 x_{1} + 1 = x_{2} \, \to \, x_{2} \ne x_{0}\]
    \item[] \[ \forall x_{2} \, x_{1}, \exists x_{0}, x_{0}^{2} + 2 x_{1} + 1 = x_{2} \, \to \, x_{2} \ne x_{0}\]
  \end{itemize}
  We only need $\bot, =, \to, \forall$, and the relation symbols from the language.

\end{frame}

\begin{frame}[fragile]{Structures in a language}
  If $L$ is a language and $M$ is a set
  then an $L$-\textit{structure} on $M$ consists of the following
    \begin{itemize}[<+->]
      \item Each function symbol $f$ of arity $n$ is interpreted as a
            function $M^{n} \to M$.
      \item Each relation symbol $r$ of arity $n$
            is interpreted as a proposition on $M^{n} \to \texttt{Prop}$,
            or equivalently as a subset $S \hookr M^{n}$.
      \vspace{1 em}

      \item[] $\N, \Z, \Q, \bar{\Q}, \F_{p}, \set{0}$ can be made into
            structures in the language of rings.
      \item[] $\varnothing$ cannot be.
    \end{itemize}
  \end{frame}

\begin{frame}[fragile]{Structures}
  Fix a structure $M$ in a language $L$.
  Terms with $n$ variables are interpreted as functions from the structure to itself.
  \begin{itemize}
    \item <2-> Variables are interpreted as projection to an affine line.
  \end{itemize}
  \pause \pause
  Formulas with $n$ free variables are interpreted as predicates
  on the structure in the obvious way. \pause
  Example: $b , c $ are elements of $M$ then
  \[\forall x_{0}, x_{0}^{2} + 2 x_{1} + 1 = x_{2}\] applied to $b, c$ is interpreted as
  the proposition \[\text{``for all $a$ in $M$, } a^{2} + 2 b + 1 = c\text{''}\]

\end{frame}

\begin{frame}[fragile]{Models}
  A theory is a set of sentences (formulas with no free variables),
  a model is a structure that satisfies all those sentences. \pause
  The theory of rings contains the sentences corresponding to
  the axioms of a ring. \pause Example: commutativity of multiplication
  \begin{lstlisting}
  def mul_comm : sentence ring_signature :=
    ∀' ∀' ( x_ 0 * x_ 1 ≃ x_ 1 * x_ 0 ) \end{lstlisting} \pause
  \begin{itemize}
    \item Ring axioms
    \item Field axioms $=$ ring axioms $\cup$ inverse $\cup$ $0 \ne 1$
    \item $\ACF$
    \item Characteristic
  \end{itemize} \pause
\end{frame}

\begin{frame}[fragile]{The Lefschetz principle}
  \begin{theorem}[Lefschetz principle]
    \link{lefschetz2}
    Let $\phi$ be a sentence in the language of rings. % EXAMPLE = exists x ≠ y , x^2 + x + 1 = 0 ∧ y^2 + y + 1 = 0
    Then the following are equivalent:
    \begin{enumerate}
        \item Some model of $\ACF_0$ satisfies $\phi$.
        (If you like $\C \vDash \phi$.)
        \item $\ACF_0 \vDash \phi$
        \item There exists $n \in \N$ such that for any prime $p$
            greater than $n$, $\ACF_p \vDash \phi$
        \item There exists $n \in \N$ such that for any prime $p$
        greater than $n$, some model of $\ACF_p$ satisfies $\phi$.
    \end{enumerate} \pause
    \begin{proof}
      \link{lefschetz_proof}
      ($1. \IFF 2.$) and ($3. \IFF 4.$) ``$\ACF_{n}$ is complete''
      by Vaught's test. \pause

      ($2. \IFF 3.$) ``$\chi$-change'' by compactness theorem.
    \end{proof}
\end{theorem}
\end{frame}

\begin{frame}[fragile]{Ax-Grothendieck proof}

\adjustbox{scale=0.8,center}{%
\begin{tikzcd}[column sep=large]
	{\text{(algebraic) Ax-G for } \bar{\F_p}} \\
	{\text{(model th.) Ax-G for } \bar{\F_{p}} } \\
	{\text{(model th.) $\chi_{p}$ Ax-G}} & {\text{(algebraic) }\chi_p \text{ Ax-G}} \\
	{\text{(model th.) }\chi_0 \text{ Ax-G}} & {\text{(algebraic) }\chi_0 \text{ Ax-G}} && {\text{(algebraic) Ax-G}}
	\arrow["{\ACF_{p} \text{is complete}}", shift right=5, from=2-1, to=3-1]
	\arrow["{\text{Lefschetz }\chi\text{-change}}", shift right=5, from=3-1, to=4-1]
  \arrow["{\text{i-soundness}}", shift right=5, from=1-1, to=2-1]
  \arrow["{\text{i-completeness}}"', from=3-1, to=3-2]
	\arrow["{\text{i-completeness}}"', from=4-1, to=4-2]
	\arrow[from=3-2, to=4-4]
	\arrow["{\text{case on }\chi}", from=4-2, to=4-4]
\end{tikzcd}
}

\end{frame}






\end{document}
